type bound_type = UPPER | LOWER

let bound_type_to_bool = function
    | UPPER -> true
    | LOWER -> false

let bound_type_to_int = function
    | UPPER -> 1i
    | LOWER -> 0i 
    [@@program]

let bound_type_to_str = function
    | UPPER -> "UPPER"
    | LOWER -> "LOWER"
    [@@program]


type constraint_type =
    | RELU
    | MAX
    | SIGN
    | DISJUNCTION
    | ABSOLUTE_VALUE
    | UNDEFINED

let all (l: bool list) = List.fold_left (fun x y -> x && y) true l

let rec repeat x n =
    if n <= 0
    then
        []
    else
        x::(repeat x (n - 1))

lemma repeat_preserve_pos_length x n =
    n >= 0 ==> List.length (repeat x n) = n
[@@auto]

(* set list element at given index to x *)
let rec set_nth (l: 'a list) (n: int) (x: 'a): 'a list =    
    if n < 0 then l
    else
    match l with
    | [] -> []
    (* | [_] when n=0 -> [x] *)
    | hd::tl ->
    if n = 0 then (
        x :: tl
    ) else (
        hd :: set_nth tl (n-1) x
    )
;;

(* set list element at given index to x *)
let rec set_nth' (l: 'a list) (n: int) (x: 'a): 'a list =    
    if n < 0 then l
    else
    match l with
    | [] -> []
    | [_] when n=0 -> [x]
    | hd::tl ->
    if n = 0 then (
        x :: tl
    ) else (
        hd :: set_nth' tl (n-1) x
    )
;;

(* lemma set_nth'_set_nth_eq l n a = 
    set_nth' l n a = set_nth l n a
[@@auto] [@@rw]
;; *)

lemma get_set_nth l n a =
    n >= 0 && n < List.length l
     ==>
     (List.nth n (set_nth l n a) = Some a)
[@@auto] [@@rw]
;;

lemma set_nth_unchanged l n m a =
  n <> m
  ==>
  List.nth m (set_nth l n a) = List.nth m l
[@@auto]

let rec induct_scheme l m n =
    match l with
    | [] -> true
    | hd::tl -> induct_scheme tl (m-1) (n-1)

lemma set_nth'_unchanged l n m a =
  n <> m
  ==>
  List.nth m (set_nth' l n a) = List.nth m l
  [@@induct functional induct_scheme]


(* increment list element at given index by 1 *)
let increment_elem (l: real list) (n: int): real list =
    match List.nth n l with
    | None -> l
    | Some value -> set_nth l n (value +. 1.)

let rec zip (x: 'a list) (y: 'b list): ('a * 'b) list =
    match x, y with
    | [], _ | _, [] -> []
    | hx::tx, hy::ty -> (hx, hy) :: (zip tx ty)

let zip_map_compare (x: 'a list) (y: 'b list) (f: 'a -> 'b -> 'c) (n: int) =
    let open Option in
    let* xn = List.nth n x in
    let* yn = List.nth n y in
    let* b = List.nth n @@ List.map (fun (a, b) -> f a b) (zip x y) in
    Some (f xn yn = b)

lemma zip_map x y f n =
     match zip_map_compare x y f n with
        | Some res -> res = true
        | None -> true
[@@auto]

    (* Add 2 lists of reals element-wise *)
let list_add (x: real list) (y: real list): real list = 
    let open List in
    map (fun (a, b) -> a +. b) (zip x y)

(* Multiply all elements in a list of reals by a constant *)
let list_scale (x: real list) (c: real): real list = 
    List.map (fun a -> a *. c) x

lemma repeat_length x n =
    n >= 0 
    ==>
    List.length (repeat x n) = n
[@@auto]

lemma zip_size1 (x: 'a list) (y: 'b list) =
    List.length x <= List.length y 
    ==>
    List.length (zip x y) = List.length x
[@@auto]

lemma zip_size2 (x: 'a list) (y: 'b list) =
    List.length y <= List.length x 
    ==>
    List.length (zip x y) = List.length y
[@@auto]

lemma zip_cons x1 x2 y1 y2 =
    zip (x1 :: x2) (y1 :: y2) = (x1, y1) :: (zip x2 y2)
[@@auto]

lemma zip_cat x1 x2 y1 y2 =
    List.length x1 = List.length y1
    ==> 
    zip (x1 @ x2) (y1 @ y2) = (zip x1 y1) @ (zip x2 y2)
[@@auto]        
