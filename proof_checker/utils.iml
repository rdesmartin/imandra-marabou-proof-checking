type bound_type = UPPER | LOWER

let bound_type_to_bool = function
    | UPPER -> true
    | LOWER -> false

let bound_type_to_int = function
    | UPPER -> 1i
    | LOWER -> 0i 
    [@@program]

type constraint_type =
    | RELU
    | MAX
    | SIGN
    | DISJUNCTION
    | ABSOLUTE_VALUE
    | UNDEFINED

let all (l: bool list) = List.fold_left (fun x y -> x && y) true l

let rec repeat x n =
    if n <= 0
    then
        []
    else
        x::(repeat x (n - 1))

(* set list element at given index to x *)
let rec set_nth (l: real list) (n: int) (x: real): real list =
    if n < 0 || n >= List.length l then 
        l
    else if n = 0 then
        match l with
        | [] -> []
        | _::tl -> x::tl
    else
        match l with
        | [] -> []
        | hd::tl -> hd::(set_nth tl (n-1) x)

(* increment list element at given index by 1 *)
let increment_elem (l: real list) (n: int): real list =
    match List.nth n l with
    | None -> l
    | Some value -> set_nth l n (value +. 1.)

let rec zip (x: 'a list) (y: 'b list): ('a * 'b) list =
    match x, y with
    | [], _ | _, [] -> []
    | hx::tx, hy::ty -> (hx, hy) :: (zip tx ty)

(* Add 2 lists of reals element-wise *)
let list_add (x: real list) (y: real list): real list = 
    let open List in
    map (fun (a, b) -> a +. b) (zip x y)

(* Multiply all elements in a list of reals by a constant *)
let list_mult (x: real list) (c: real): real list = 
    List.map (fun a -> a *. c) x
