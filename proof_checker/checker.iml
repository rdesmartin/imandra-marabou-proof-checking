open Utils
open Proof_tree
open Arithmetic
open Check_splits
open Tightening
open Bound_lemma
open Constraint
open Farkas_lemma
open Certificate

type query = {
    tableau: real list list;
    upper_bounds: real list;
    lower_bounds: real list;
    constraints: Constraint.t list;
    proof_tree: ProofTree.t;
}

(* check that the contradiction is a valid Farkas lemma vector in matrix/vector representation *)
let check_contradiction' contradiction (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list): bool =
    let linear_combination = LinArith.compute_combination contradiction tableau in
    let row_upper_bound = LinArith.compute_row_upper_bound linear_combination upper_bounds lower_bounds in
    row_upper_bound <. 0.

(* check contradiction with polynomials representation *)
let check_contradiction (contradiction: real list) (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list): bool = 
    let sys = mk_system_contradiction contradiction tableau upper_bounds lower_bounds in
    (* The original contradiction vector has 1 value per tableau row.
       When we convert the tableau & bounds to the system, we add Geq constraints that we already scale. 
       We append 1s at the end of the contradiction vector to account for these new constraints. *)
    let contradiction' = contradiction @ (repeat 1. (List.length upper_bounds)) in
    let res = (check_cert sys contradiction') in
    res

(* check that a node's childrens' splits are non-empty and correctly divide the search space (ReLU and Single Variable splits are hardcoded) *)
let check_children_splits children constraints =
    let children_tightenings = List.map ProofTree.get_tightening children in
    let non_empty_children_splits = all ((List.map ProofTree.non_empty_tightening) children) in
    let valid_relu_split = check_relu_split children_tightenings constraints in
    let valid_single_var_split = check_single_var_split children_tightenings in
    non_empty_children_splits && (valid_relu_split || valid_single_var_split)

(** Recursively check nodes in the proof tree
    First, update the bounds according to the split.
    We then check that the dynamic bound tightenings performed at this step are valid, and we apply them. 
   
    If the node is not a leaf, we then check that its children split the search space correctly (either 2 phases of relu or single var split TODO: what is single var split again?)
    Then we recursively apply `check_node` on all the node's children.

    If the node is a Leaf, we check that the saved proof vector leads to a contradiction
    *)
let rec check_node tableau upper_bounds lower_bounds constraints proof_node =
    match proof_node with
    | ProofTree.Node (tightenings, bound_lemmas, children) ->
        let (upper_bounds', lower_bounds') = Tightening.update_bounds tightenings upper_bounds lower_bounds in
        let (valid_bounds, upper_bounds'', lower_bounds'') = BoundLemma.check_bound_lemmas bound_lemmas tableau upper_bounds' lower_bounds' constraints in
        let valid_children_splits = check_children_splits children constraints in
        let valid_children = all (List.map (check_node tableau upper_bounds'' lower_bounds'' constraints) children) in
        valid_bounds && valid_children_splits && valid_children
    | ProofTree.Leaf (tightenings, bound_lemmas, contradiction) ->
        let (upper_bounds', lower_bounds') = Tightening.update_bounds tightenings upper_bounds lower_bounds in
        let (valid_bounds, upper_bounds'', lower_bounds'') = BoundLemma.check_bound_lemmas bound_lemmas tableau upper_bounds' lower_bounds' constraints in
        let valid_contradiction = check_contradiction contradiction tableau upper_bounds'' lower_bounds'' in
        valid_bounds && valid_contradiction

let rec equal_rows_length tableau size = 
    match tableau with
    | hd :: tl -> List.length hd = size && equal_rows_length tl size
    | [] -> true

let well_formed_tableau tableau = 
    tableau <> [] &&
    List.hd tableau <> [] && 
    equal_rows_length tableau (List.length (List.hd tableau))
    
(* Return true if the dimensions of the bounds are the same and if the length of 
   the bounds is greater than the number of rows in the tableau
   todo: ask clarification about second condition
*)
let sanity_checks tableau upper_bounds lower_bounds =
    let valid_bounds_sizes = List.length upper_bounds = List.length lower_bounds && List.length lower_bounds <> 0 in
    let tableau_well_formed = well_formed_tableau tableau in
    valid_bounds_sizes && tableau_well_formed


(* Main entry point to verify the proof tree.
   - perform sanity checks on the tableau and upper and lower bound vector dimensions.
   - check the tree recursively starting from the root. We use pattern matching to check 
   that the root node contains no dynamic bound tightenings. 
   The function `check_node` will traverse the tree recursively; so if it returns true, 
   it means that the proof is valid, i.e.all the bound tightenings are correct and 
   all the contradiction vectors correpond to a contradiction. 
*)
let check_proof_tree (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list) (constraints: Constraint.t list) (proof_root: ProofTree.t) =
    let sanity_check_res = sanity_checks tableau upper_bounds lower_bounds in
    let check_tree = 
        match proof_root with
        | ProofTree.Node ([], bound_lemmas, _) | ProofTree.Leaf ([], bound_lemmas, _) ->
            check_node tableau upper_bounds lower_bounds constraints proof_root
        | _ -> false
    in
    sanity_check_res && check_tree
