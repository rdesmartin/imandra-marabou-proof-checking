open Utils
open Proof_tree
open Arithmetic
open Check_splits
open Tightening
open Bound_lemma
open Constraint
open Farkas_lemma
open Certificate

(* check contradiction with polynomials representation *)
let check_contradiction (contradiction: Real.t list) (tableau: exp list) (upper_bounds: Real.t list) (lower_bounds: Real.t list): bool = 
    let sys = mk_system_contradiction tableau upper_bounds lower_bounds in
    let lc = LinArith.compute_combination contradiction tableau in        
    let contradiction' = contradiction @ ((mk_upper_bound_certificate lc) @ (mk_lower_bound_certificate lc)) in
    let res = (check_cert sys contradiction') in
    res

(* check that a node's childrens' splits are non-empty and correctly divide the search space (ReLU and Single Variable splits are hardcoded) *)
let check_children_splits (l_t: Tightening.t list) (r_t: Tightening.t list) (constraints: Constraint.t list) =
    let non_empty_children_splits = l_t <> [] && r_t <> [] in
    let valid_relu_split = check_relu_split l_t r_t constraints in
    let valid_single_var_split = check_single_var_split l_t r_t in
    non_empty_children_splits && (valid_relu_split || valid_single_var_split)

(** Recursively check nodes in the proof tree
    First, update the bounds according to the split.
    We then check that the dynamic bound tightenings performed at this step are valid, and we apply them. 
   
    If the node is not a leaf, we then check that its children split the search space correctly (either 2 phases of relu or single var split TODO: what is single var split again?)
    Then we recursively apply `check_node` on all the node's children.

    If the node is a Leaf, we check that the saved proof vector leads to a contradiction
    *)
let rec check_node (tableau: exp list) (upper_bounds: Real.t list) (lower_bounds: Real.t list) (constraints: Constraint.t list) (proof_node: ProofTree.t) =
    match proof_node with
    | ProofTree.Leaf (bound_lemmas, contradiction) ->
        let (valid_bounds, upper_bounds', lower_bounds') = BoundLemma.check_bound_lemmas bound_lemmas tableau upper_bounds lower_bounds constraints in
        let valid_contradiction = check_contradiction contradiction tableau upper_bounds' lower_bounds' in
        valid_bounds && valid_contradiction
    | ProofTree.Node (bound_lemmas, left_child, right_child, left_tight, right_tight) ->
        let (valid_bounds, upper_bounds', lower_bounds') = BoundLemma.check_bound_lemmas bound_lemmas tableau upper_bounds lower_bounds constraints in
        let valid_children_splits = check_children_splits left_tight right_tight constraints in
        let (lb_left, ub_left) = Tightening.update_bounds left_tight upper_bounds' lower_bounds' in
        let (lb_right, ub_right) = Tightening.update_bounds right_tight upper_bounds' lower_bounds' in
        let valid_children = (check_node tableau ub_left lb_left constraints left_child) &&
            (check_node tableau ub_right lb_right constraints right_child) in
        if not valid_bounds then 
        let () = Printf.printf "invalid bounds\n" in
        false
        else if not valid_children_splits then
        let () = Printf.printf "invalid split\n" in false
        else
        valid_bounds && valid_children_splits && valid_children
    [@@adm proof_node]

let rec equal_rows_length tableau size = 
    match tableau with
    | hd :: tl -> List.length hd = size && equal_rows_length tl size
    | [] -> true

let well_formed_tableau tableau = 
    tableau <> [] &&
    List.hd tableau <> [] && 
    equal_rows_length tableau (List.length (List.hd tableau))
    
(* Return true if the dimensions of the bounds are the same and if the length of 
   the bounds is greater than the number of rows in the tableau
   todo: ask clarification about second condition
*)
let sanity_checks tableau upper_bounds lower_bounds =
    let valid_bounds_sizes = List.length upper_bounds = List.length lower_bounds && List.length lower_bounds <> 0 in
    let tableau_bounds_match = List.length upper_bounds = List.length (List.hd tableau) in
    let tableau_well_formed = well_formed_tableau tableau in
    valid_bounds_sizes && tableau_well_formed && tableau_bounds_match


(* Main entry point to verify the proof tree.
   - perform sanity checks on the tableau and upper and lower bound vector dimensions.
   - check the tree recursively starting from the root. We use pattern matching to check 
   that the root node contains no dynamic bound tightenings. 
   The function `check_node` will traverse the tree recursively; so if it returns true, 
   it means that the proof is valid, i.e.all the bound tightenings are correct and 
   all the contradiction vectors correpond to a contradiction. 
*)
let check_proof_tree (tableau: Real.t list list) (upper_bounds: Real.t list) (lower_bounds: Real.t list) (constraints: Constraint.t list) (proof_root: ProofTree.t) =
    let sanity_check_res = sanity_checks tableau upper_bounds lower_bounds in
    let tableau_system = mk_eq_constraints tableau in
    let check_tree = check_node tableau_system upper_bounds lower_bounds constraints proof_root in
    sanity_check_res && check_tree
