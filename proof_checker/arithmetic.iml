open Utils
open Farkas_lemma

module LinArith = struct
    (** is_bounded returns true is the vector xs is bounded by us and ls, i.e. for each corresponding
        elements x_i, l_i, u_i, l_i <= x <= u_i *)
    let rec is_upper_bounded x u = 
    match x, u with
    | [], [] -> true
    | [x], [u] -> x <=. u
    | x :: xs, u :: us -> x <=. u && is_upper_bounded xs us
    | _ -> false

    lemma is_upper_bounded_elem x u n = 
        is_upper_bounded x u
        ==>
        match (List.nth n x), (List.nth n u) with
        | (Some x), (Some u) -> x <=. u
        | _ -> true
    [@@auto]

    let is_bounded x u l = is_upper_bounded l x && is_upper_bounded x u

    lemma is_bounded_elem x u l n =
        is_bounded x u l
        ==>
        match (List.nth n x), (List.nth n u), (List.nth n l) with
        | (Some x), (Some u), (Some l) -> l <=. x && x <=. u
        | _ -> true
    [@@auto][@@apply is_upper_bounded_elem l x n, is_upper_bounded_elem x u n]

    (** dot-product (or scalar product) of vector x and y, defined with List.map and zip *)
    let dot_product x y = List.fold_left (+.) 0. (List.map (fun (a, b) -> a *. b) (zip x y))
    
    (** dot-product (or scalar product) of vector x and y, defined recursively (legacy) *)
    let rec dot_product' x y =
        match x, y with
        | [], [] -> 0.
        | x1::xs, y1::ys -> x1 *. y1 +. (dot_product' xs ys)
        | _ -> 0.
    
    (** Helper function for {!compute_combination} *)
    let rec update_combination (lc: real list) (expl: real list) (tableau: exp list): real list = 
        match expl, tableau with
        | _, [] | [], _ -> lc
        | coeff :: expl', row :: tableau' -> update_combination (list_add lc (list_scale (extract_poly row) coeff)) expl' tableau'

    (** Compute a linear combination of tableau rows with coefficients from the explanation vector `expl` 
        (i.e. a bound-tightening lemma vector or a contradiction in a Leaf node) 
        The initial zero vector accumulator has length (len p - 1) because the polynomials have a constant factor, 
        and we want it to be the size of the variable vector
        *)        
    let compute_combination (expl: real list) (tableau: exp list): real list =
        match tableau with
        | [] -> []
        | (hd::tl as tableau) -> update_combination (repeat 0. (List.length (extract_poly hd) - 1)) expl tableau

        (** Helper function for {!compute_row_upper_bound} *)
    let upper_bound_acc_fun bound (coeff, (upper_bound, lower_bound)) =
        if coeff <. 0. 
        then 
            bound +. (lower_bound *. coeff)
        else
            bound +. (upper_bound *. coeff)

    (** Compute the upper bound for a tableau row represented as list of reals *)
    let rec compute_row_upper_bound (row: real list) (upper_bounds: real list) (lower_bounds: real list): real =
        match row, upper_bounds, lower_bounds with
        | row_h :: row_t, upp_h :: upp_t, low_h :: low_t -> 
            if row_h >. 0. 
            then row_h *. upp_h +. (compute_row_upper_bound row_t upp_t low_t)
            else row_h *. low_h +. (compute_row_upper_bound row_t upp_t low_t)
        | _ -> 0.

    let rec upper_bound_induct_scheme x row = 
        match x, row with
        | x_h :: x_t, row_h :: row_t -> upper_bound_induct_scheme x_t row_t
        | _ -> true

    (* lemma upper_bound_for_bounded_row x row us ls u =
        is_bounded x us ls &&
        compute_row_upper_bound row us ls = u
        ==>
        dot_product x row <=. u
    [@@induct functional upper_bound_induct_scheme] *)

    (** Helper function for {!compute_row_lower_bound}  *)
    let lower_bound_acc_fun bound (coeff, (upper_bound, lower_bound)) =
        if coeff <. 0. 
        then 
            bound +. (upper_bound *. coeff)
        else
            bound +. (lower_bound *. coeff)

    (** Compute the upper bound for a tableau row represented as list of reals *)
    let compute_row_lower_bound (row: real list) (upper_bounds: real list) (lower_bounds: real list) =
        List.fold_left lower_bound_acc_fun 0. (zip row (zip upper_bounds lower_bounds))

end