open Utils

module LinArith = struct

    let update_combination (lc: real list) ((coeff, row): real * real list): real list = 
        list_add lc (list_mult row coeff)

    (* compute a linear combination of tableau rows with coefficients from an explanation vector 
    (i.e. a lemma vector or a contradiction in a Leaf node) *)
    let compute_combination (expl: real list) (tableau: real list list): real list =
        if tableau = []
        then
            []
        else
            let linear_combination = (repeat 0. (List.length (List.hd tableau))) in
            List.fold_left update_combination linear_combination (zip expl tableau)

    let upper_bound_acc_fun bound (coeff, (upper_bound, lower_bound)) =
        if coeff <. 0. 
        then 
            bound +. (lower_bound *. coeff)
        else
            bound +. (upper_bound *. coeff)

    (* compute the upper bound for a tableau row represented as list of reals *)
    let compute_row_upper_bound (row: real list) (upper_bounds: real list) (lower_bounds: real list) =
        List.fold_left upper_bound_acc_fun 0. (zip row (zip upper_bounds lower_bounds))


    let lower_bound_acc_fun bound (coeff, (upper_bound, lower_bound)) =
        if coeff <. 0. 
        then 
            bound +. (upper_bound *. coeff)
        else
            bound +. (lower_bound *. coeff)

    (* compute the upper bound for a tableau row represented as list of reals *)
    let compute_row_lower_bound (row: real list) (upper_bounds: real list) (lower_bounds: real list) =
        List.fold_left lower_bound_acc_fun 0. (zip row (zip upper_bounds lower_bounds))

end