open Farkas_lemma
open Arithmetic.LinArith
open Tightening
open Utils

(* create certificate for Geq constraints corresponding to upper bounds *)
let rec mk_upper_bound_certificate lc = 
  match lc with 
  | [] -> []
  | hd :: tl -> (if hd >=. 0. then hd else 0. ) :: mk_upper_bound_certificate tl


(* create certificate for Geq constraints corresponding to lower bounds *)
let rec mk_lower_bound_certificate lc = 
  match lc with 
  | [] -> []
  | hd :: tl -> (if hd <. 0. then (-. hd) else 0. ) :: mk_lower_bound_certificate tl

(*
  Create a polynomial of size (size + 1) that represents the bound of variable i:
  all coefficients are 0, except at index i where it is  `coeff` (should be 1 for a lower bound
  and -1 for an upper bound). The constant is the value of the bound.
*)
let rec mk_bound_poly (size: int) (i: int) (coeff: real) (bound: real): real list =
  if size < 0 then []
  else if size = 0 then [bound]
  else (
    let el = if i = 0 then coeff else 0. in
    el :: mk_bound_poly (size - 1) (i - 1) coeff bound
  )

(* 
  transform the tableau into a list of Eq expressions, with 
  an added 0. for the constant at the end 
*)
let rec mk_eq_constraints (tableau: real list list): exp list =
  match tableau with 
  | hd :: tl -> Eq (hd @ [0.]) :: mk_eq_constraints tl
  | [] -> []

(** Creates a Geq constraint of the form `x_n - l_n >= 0` for each bound l_n in the lower_bound vector
    size = number of variables
*)
let rec mk_lower_bounds_constraints size i lower_bounds = 
  match lower_bounds with
  | [] -> []
  | l::bounds -> Geq (mk_bound_poly size i 1. (-. l)) :: mk_lower_bounds_constraints size (i + 1) bounds

(** Iden for upper_bounds *)
let rec mk_upper_bounds_constraints size i upper_bounds = 
  match upper_bounds with
  | [] -> []
  | u::bounds -> Geq (mk_bound_poly size i (-1.) u) :: mk_upper_bounds_constraints size (i + 1) bounds

(** Create Geq constraints corresponding to the variable bounds.
*)
let mk_geq_constraints (upper_bounds: real list) (lower_bounds: real list): exp list =
  let size = List.length upper_bounds in
  (mk_upper_bounds_constraints size 0 upper_bounds) @ (mk_lower_bounds_constraints size 0 lower_bounds)
 

let mk_gt_constraint (size: int) ((var, value, bound_t): (int * real * bound_type)): exp = 
  match bound_t with
  | UPPER -> let p: real list = mk_bound_poly size var 1. (-. value) in
             Gt p
  | LOWER -> let p: real list = mk_bound_poly size var (-1.) value in
             Gt p

(* Create the polynomial representation of the linear constraints from the matrix representation *)
let mk_system_contradiction (tableau: exp list) (upper_bounds: real list) (lower_bounds: real list): exp list =
  tableau @ (mk_geq_constraints upper_bounds lower_bounds)

(* Create the polynomial representation of the linear constraints from the matrix representation 
   for bound tightening lemma checking, i.e. with strict inequality constraints *)
let mk_system_lemma (tableau: exp list) (upper_bounds: real list) (lower_bounds: real list) ((caus_var, row_bound, caus_bound_t) as tightening: Tightening.t): exp list =
  let geq_constraints = mk_geq_constraints upper_bounds lower_bounds in
  let gt_constraint = mk_gt_constraint (List.length upper_bounds) tightening in
  gt_constraint :: (tableau @ geq_constraints)
