open Farkas_lemma
open Arithmetic

(*
  Create a polynomial of (size + 1) that represents the bound of variable i:
  all coefficients are 0, except at index i where it is 1 for lower bound
  and -1 for upper bounds. The constant is the value of the bound.
*)
let rec mk_bound_poly (size: int) (i: int) (coeff: real) (bound: real) =
  if size < 0 then []
  else if size = 0 then [bound]
  else (
    let el = if i = 0 then coeff else 0. in
    el :: mk_bound_poly (size - 1) (i - 1) coeff bound
  )

(* return the polynomial from the expression (just the coefficients) *)
let extract_poly (e: exp) =
  match e with
  | Geq (i, e) -> e
  | Eq e -> e

(* 
  transform the tableau into a list of Eq expressions, with 
  an added 0. for the constant at the end 
*)
let mk_eq_constraints (tableau: real list list): exp list = 
  List.map (fun x -> Eq (x @ [0.])) tableau

(* 
  recursively iterate over the coeffs computed with w^T . A. 
  For each coeff, create a Geq expr for the upper bounds if positive, 
  Geq expr for the lower bound if negative.
  For now, we scale by the coeff here and add 1 to the final 
  certificate coefficients vector.
  size = number of variables
*)
let rec mk_geq_constraints' (cs: real list) (upper_bounds: real list) (lower_bounds: real list) (i: int) (size: int): exp list =
  match cs, upper_bounds, lower_bounds with
  | [], [], [] -> []
  | c :: cs, u :: us, l :: ls -> 
      let p = if (c >=. 0.)
              then (
                mk_bound_poly size i Real.(-1. * c) Real.(u * c)
              ) else (
                mk_bound_poly size i Real.(1. * -c) Real.(-l * -c)
              )
      in
      Geq (i, p) :: mk_geq_constraints' cs us ls (i + 1) size
  | _ -> []

(*
  Create Geq constraints corresponding to the variable bounds.
*)
let mk_geq_constraints (cs: real list) (upper_bounds: real list) (lower_bounds: real list): exp list =
  let size = List.length cs in
  mk_geq_constraints' cs upper_bounds lower_bounds 0 size

(* Create the polynomial representation of the linear constraints from the matrix representation *)
let mk_system (expl: real list) (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list): exp list =
    let eq_constraints = mk_eq_constraints tableau in
    let tableau_linear_combination = LinArith.compute_combination expl tableau in
    let geq_constraints = mk_geq_constraints tableau_linear_combination upper_bounds lower_bounds in
    eq_constraints @ geq_constraints
    
(* Utils to_string functions for debugging *)
let rec poly_to_string p = 
  match p with 
  | [] -> "\n"
  | p :: ps -> Printf.sprintf "%f; " (Q.to_float p) ^ poly_to_string ps
[@@program]

let rec system_to_string system = 
  match system with 
  | [] -> "\n"
  | Geq (var, e) :: es -> "Geq " ^ poly_to_string e ^ system_to_string es
  | Eq e :: es -> "Eq " ^ poly_to_string e ^ system_to_string es
[@@program]