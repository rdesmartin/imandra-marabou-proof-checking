open Farkas_lemma
open Arithmetic.LinArith
open Tightening
open Utils

(*
  Create a polynomial of size (size + 1) that represents the bound of variable i:
  all coefficients are 0, except at index i where it is  `coeff` (should be 1 for a lower bound
  and -1 for an upper bound). The constant is the value of the bound.
*)
let rec mk_bound_poly (size: int) (i: int) (coeff: real) (bound: real): real list =
  if size < 0 then []
  else if size = 0 then [bound]
  else (
    let el = if i = 0 then coeff else 0. in
    el :: mk_bound_poly (size - 1) (i - 1) coeff bound
  )

(* return the polynomial from the expression (just the coefficients) *)
let extract_poly (e: exp): real list =
  match e with
  | Geq e -> e
  | Eq e -> e
  | Gt e -> e

(* 
  transform the tableau into a list of Eq expressions, with 
  an added 0. for the constant at the end 
*)
let rec mk_eq_constraints (tableau: real list list): exp list =
  match tableau with 
  | hd :: tl -> Eq (hd @ [0.]) :: mk_eq_constraints tl
  | [] -> []

(* 
  recursively iterate over the coeffs computed with w^T . A. 
  For each coeff, create a Geq expr for the upper bounds if positive, 
  Geq expr for the lower bound if negative.
  For now, we scale by the coeff here and add 1 to the final 
  certificate coefficients vector.
  size = number of variables
*)

let mk_geq_poly c u l i size =
  if (c >=. 0.)
  then (
    mk_bound_poly size i Real.(-1. * c) Real.(u * c)
  ) else (
    mk_bound_poly size i Real.(1. * -c) Real.(-l * -c)
  )


let rec mk_geq_constraints' (cs: real list) (upper_bounds: real list) (lower_bounds: real list) (i: int) (size: int): exp list =
  match cs, upper_bounds, lower_bounds with
  | [], [], [] -> []
  | c :: cs, u :: us, l :: ls -> 
      let p = mk_geq_poly c u l i size in 
      Geq p :: mk_geq_constraints' cs us ls (i + 1) size
  | _ -> []

(*
  Create Geq constraints corresponding to the variable bounds.
*)
let mk_geq_constraints (cs: real list) (upper_bounds: real list) (lower_bounds: real list): exp list =
  let size = List.length cs in
  mk_geq_constraints' cs upper_bounds lower_bounds 0 size


let mk_gt_constraint (size: int) ((var, value, bound_t): (int * real * bound_type)): exp = 
  match bound_t with
  | UPPER -> let p: real list = mk_bound_poly size var 1. (-. value) in
             Gt p
  | LOWER -> let p: real list = mk_bound_poly size var (-1.) value in
             Gt p

(* Create the polynomial representation of the linear constraints from the matrix representation *)
let mk_system_contradiction (expl: real list) (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list): exp list =
  (mk_eq_constraints tableau) @ (mk_geq_constraints (compute_combination expl tableau) upper_bounds lower_bounds)
(* let eq_constraints = mk_eq_constraints tableau in
    let tableau_linear_combination = LinArith.compute_combination expl tableau in
    let geq_constraints = mk_geq_constraints tableau_linear_combination upper_bounds lower_bounds in
    eq_constraints @ geq_constraints *)



(* Create the polynomial representation of the linear constraints from the matrix representation 
   for bound tightening lemma checking, i.e. with strict inequality constraints *)
let mk_system_lemma (expl: real list) (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list) ((caus_var, row_bound, caus_bound_t) as tightening: Tightening.t): exp list =
  let eq_constraints = mk_eq_constraints tableau in
  let tableau_linear_combination = if caus_bound_t = UPPER
            then compute_combination expl tableau
            else compute_combination (list_scale expl (-1.)) tableau
  in
  let updated_linear_combination =  if caus_bound_t = UPPER
    then (increment_elem tableau_linear_combination caus_var)
    else (decrement_elem tableau_linear_combination caus_var)
  in
  let geq_constraints = mk_geq_constraints updated_linear_combination upper_bounds lower_bounds in
  let gt_constraint = mk_gt_constraint (List.length tableau_linear_combination) tightening in
  gt_constraint :: (eq_constraints @ geq_constraints)
  (* mk_system_lemma expl tableau upper_bounds lower_bounds tightening: expr list

  equivalence lemma:
  forall x
  (eval expl tableau upper_bounds lower_bounds tightening x) 
  =
  s (mk_system_lemma expl tableau upper_bounds lower_bounds tightening) 
  *)



(* Utils to_string functions for debugging *)
let rec poly_to_string p = 
  match p with 
  | [] -> "\n"
  | p :: ps -> Printf.sprintf "%f; " (Q.to_float p) ^ poly_to_string ps
[@@program]

let rec system_to_string system = 
  match system with 
  | [] -> "\n"
  | Geq e :: es -> "Geq " ^ poly_to_string e ^ system_to_string es
  | Eq e :: es -> "Eq " ^ poly_to_string e ^ system_to_string es
  | Gt e :: es -> "Gt " ^ poly_to_string e ^ system_to_string es
[@@program]