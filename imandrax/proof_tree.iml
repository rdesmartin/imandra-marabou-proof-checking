(* 
  Proof tree structure
*)

[@@@import "tightening.iml"]
[@@@import "util.iml"]
[@@@import "constraint.iml"]
[@@@import "split.iml"]

open Util
open Tightening
open Constraint
open Split

(* Marabou proof tree type *)
module MT = struct
      type t = 
        (* tightening, bounds lemmas, left child, right child *)
        (* | Node of Tightening.t list * BoundLemma.t list * t * t *)
        | Node of Tightening.t list * t * t
        (* tightening, bounds lemmas, contradiction vector *)
        (* | Leaf of Tightening.t list * BoundLemma.t list * real list *)
        | Leaf of Tightening.t list * real list
    
      let non_empty_tightening n = match n with
        | Node ([], _, _) | Leaf ([], _) -> false
        | _ -> true
    
      let get_tightening n = match n with
        | Node (tightening, _, _)
        | Leaf (tightening, _) -> tightening
(*     
        let get_bound_lemmas n = match n with
        | Node (_, bound_lemmas, _, _)
        | Leaf (_, bound_lemmas, _) -> bound_lemmas *)

end 

(* information about child node: pointer to tree, bound-tightening and bound propagation info *)
  type t = 
    (*  left child, right child *)
    | Node of Split.t * t * t 
    (* contradiction vector *)
    | Leaf of real list 

(* Convert Proof Tree as generated by Marabou to new representation *)
let rec of_marabou_tree (old_tree: MT.t) (constraints: Constraint.t list): t option = 
    match old_tree with
    | MT.Node (tightenings, child_l, child_r) -> 
        let split = Split.match_split (MT.get_tightening child_l) (MT.get_tightening child_r) constraints in
        let left = of_marabou_tree child_l constraints in
        let right = of_marabou_tree child_r constraints in
        (match split, left, right with
        | Some split, Some left, Some right -> 
            Some (Node (split, left, right))
        | None, Some _, Some _ -> 
            None
        | _ -> None)
    | MT.Leaf (tightenings, contradiction) ->
      Some (Leaf (contradiction))