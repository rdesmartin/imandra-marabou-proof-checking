(* GP Status: PROVED! *)

[@@@import "tightening.iml"]
[@@@import "util.iml"]
[@@@import "bound_lemma.iml"]

open Util
open Tightening
open Bound_lemma

(* `Old' proof tree *)
module MT = struct

      type t = 
        (* tightening, bounds lemmas, left child, right child *)
        | Node of Tightening.t list * BoundLemma.t list * t * t
        (* tightening, bounds lemmas, contradiction vector *)
        | Leaf of Tightening.t list * BoundLemma.t list * real list
    
      let non_empty_tightening n = match n with
        | Node ([], _, _, _) | Leaf ([], _, _) -> false
        | _ -> true
    
      let get_tightening n = match n with
        | Node (tightening, _, _, _)
        | Leaf (tightening, _, _) -> tightening
    
        let get_bound_lemmas n = match n with
        | Node (_, bound_lemmas, _, _)
        | Leaf (_, bound_lemmas, _) -> bound_lemmas

end 

(* information about child node: pointer to tree, bound-tightening and bound propagation info *)
  type child_info = {
    ptr: t;
    tightenings: Tightening.t list;
    bound_lemmas: BoundLemma.t list;
  } and t = 
    (*  left child, right child *)
    | Node of child_info * child_info
    (* contradiction vector *)
    | Leaf of real list

   (* Convert Proof Tree as generated by Marabou to new representation *)
let rec of_marabou_tree old_tree = 
    match old_tree with
    | MT.Node (tightenings, bound_lemmas, child_l, child_r) -> 
        let child_info_l = { 
          ptr = of_marabou_tree child_l;
          tightenings = MT.get_tightening child_l;
          bound_lemmas = MT.get_bound_lemmas child_l;
        } in
        let child_info_r = {
          ptr = of_marabou_tree child_r;
          tightenings = MT.get_tightening child_r;
          bound_lemmas = MT.get_bound_lemmas child_r;
        } in
        Node (child_info_l, child_info_r)
    | MT.Leaf (tightenings, bound_lemmas, contradiction) ->
      Leaf (contradiction)