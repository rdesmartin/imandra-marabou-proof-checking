(* GP Status: PROVED! *)

[@@@import "tightening.iml"]
[@@@import "util.iml"]
[@@@import "bound_lemma.iml"]
[@@@import "split.iml"]

open Util
open Tightening
open Bound_lemma

(* `Old' proof tree *)
module MT = struct

      type t = 
        (* tightening, bounds lemmas, left child, right child *)
        | Node of Tightening.t list * BoundLemma.t list * t * t
        (* tightening, bounds lemmas, contradiction vector *)
        | Leaf of Tightening.t list * BoundLemma.t list * real list
    
      let non_empty_tightening n = match n with
        | Node ([], _, _, _) | Leaf ([], _, _) -> false
        | _ -> true
    
      let get_tightening n = match n with
        | Node (tightening, _, _, _)
        | Leaf (tightening, _, _) -> tightening
    
        let get_bound_lemmas n = match n with
        | Node (_, bound_lemmas, _, _)
        | Leaf (_, bound_lemmas, _) -> bound_lemmas

end 

(* information about child node: pointer to tree, bound-tightening and bound propagation info *)
  type t = 
    (*  left child, right child *)
    | Node of Split.t * BoundLemma.t list * t * t 
    (* contradiction vector *)
    | Leaf of real list * BoundLemma.t list

(* Convert Proof Tree as generated by Marabou to new representation *)
let rec of_marabou_tree (old_tree: MT.t) (constraints: Constraint.t list): t option = 
    match old_tree with
    | MT.Node (tightenings, bound_lemmas, child_l, child_r) -> 
        let split = Split.match_split (MT.get_tightening child_l) (MT.get_tightening child_r) constraints in
        let left = of_marabou_tree child_l constraints in
        let right = of_marabou_tree child_r constraints in
        (match split, left, right with
        | Some split, Some left, Some right -> 
          (* let () = if Split.is_single_var split then Printf.printf "single var split\n" else () in *)
          if (Split.swap_split split (MT.get_tightening child_l) (MT.get_tightening child_r)) then 
            Some (Node (split, bound_lemmas, right, left))
          else 
            Some (Node (split, bound_lemmas, left, right))
        | None, Some _, Some _ -> 
          (* let () = Printf.printf "Invalid split" in  *)
          None
        | _ -> None)
    | MT.Leaf (tightenings, bound_lemmas, contradiction) ->
      Some (Leaf (contradiction, bound_lemmas))