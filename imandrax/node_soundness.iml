[@@@import "util.iml"]
[@@@import "relu.iml"]
[@@@import "certificate.iml"]
[@@@import "proof_tree.iml"]
[@@@import "tightening.iml"]
[@@@import "split.iml"]
[@@@import "checker.iml"]
[@@@import "sat.iml"]
[@@@import "arithmetic.iml"]
[@@@import "constraint.iml"]
[@@@import "relu_split_soundness.iml"]
[@@@import "single_var_split_soundness.iml"]

open Util
open Relu
open Proof_tree
open Certificate
open Tightening
open Split
open Checker
open Sat
open Arithmetic
open Constraint
open Relu_split_soundness
open Single_var_split_soundness
open Farkas

lemma split_matching tableau upper_bounds lower_bounds constraints x split =
    let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
    List.length x = List.length lower_bounds 
    && List.length x = List.length upper_bounds
    ==>
    match split with
    | ReluSplit (b, f, aux) -> 
        List.mem (Relu (b,f,aux)) constraints
        && sat tableau upper_bounds lower_bounds constraints x
        ==>
        sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x
    | SingleSplit (i, k) -> 
        sat tableau upper_bounds lower_bounds constraints x
        ==>
        sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x
    [@@by [%use soundness_relu_split_matching tableau upper_bounds lower_bounds constraints x split] 
        @> [%use soundness_single_var_split_matching tableau upper_bounds lower_bounds constraints x split]
        @> auto]

lemma soundness_split_helper tableau upper_bounds lower_bounds constraints x split =
    let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
    List.length x = List.length lower_bounds 
    && List.length x = List.length upper_bounds
    && check_split split constraints
    ==>
    match split with
    | ReluSplit (b, f, aux) -> 
        sat tableau upper_bounds lower_bounds constraints x
        ==>
        sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x
    | SingleSplit (i, k) -> 
        sat tableau upper_bounds lower_bounds constraints x
        ==>
        sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x
    [@@by [%use split_matching tableau upper_bounds lower_bounds constraints x split] 
        @> auto]

lemma soundness_split tableau upper_bounds lower_bounds constraints x split =
    let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
    List.length x = List.length lower_bounds 
    && List.length x = List.length upper_bounds
    && check_split split constraints
    && sat tableau upper_bounds lower_bounds constraints x
    ==>
    sat tableau ub_left lb_left constraints x 
    || sat tableau ub_right lb_right constraints x
[@@by [%use soundness_split_helper tableau upper_bounds lower_bounds constraints x split] 
    @> auto]
[@@fc]

lemma soundness_split_contra tableau upper_bounds lower_bounds constraints x split =
    let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
    List.length x = List.length lower_bounds 
    && List.length x = List.length upper_bounds
    && check_split split constraints
    && not (sat tableau ub_left lb_left constraints x 
        && sat tableau ub_right lb_right constraints x)
    ==>
    not (sat tableau upper_bounds lower_bounds constraints x)
[@@by [%use soundness_split tableau upper_bounds lower_bounds constraints x split] 
    @> auto]
[@@fc]

(* lemma soundness_split_matching tableau upper_bounds lower_bounds constraints x proof_tree =
    match proof_tree with
    | Leaf _ -> true
    | Node (split, bound_lemmas, left, right) ->
        let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
        List.length x = List.length lower_bounds 
        && List.length x = List.length upper_bounds
        && check_split split constraints
        && sat tableau upper_bounds lower_bounds constraints x
        ==>
        sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x
        (* we want to apply soundness_split *)
    [@@by auto]
    [@@disable Split.update_bounds_from_split]
    [@@fc] *)

(* lemma soundness_split_matching_contra tableau upper_bounds lower_bounds constraints x proof_tree =
    match proof_tree with
    | Leaf _ -> true
    | Node (split, bound_lemmas, left, right) ->
        let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
        List.length x = List.length lower_bounds 
        && List.length x = List.length upper_bounds
        && check_split split constraints
        && not (sat tableau ub_left lb_left constraints x 
        || sat tableau ub_right lb_right constraints x) 
        ==>
        not (sat tableau upper_bounds lower_bounds constraints x)
    [@@by [%use soundness_split_matching tableau upper_bounds lower_bounds constraints x proof_tree]
        @> auto]
    [@@disable Split.update_bounds_from_split]
    [@@fc] *)

lemma check_node_parent_imply_check_node_children tableau upper_bounds lower_bounds constraints tree =
    match tree with 
    | Leaf _ -> true
    | Node (split, b_l, left, right) ->
        let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lower_bounds upper_bounds split in
        check_node tableau upper_bounds lower_bounds constraints tree 
        ==>
        (check_node tableau ub_left lb_left constraints left) 
            && (check_node tableau ub_right lb_right constraints right)
[@@by auto]
[@@disable check_node, update_bounds_from_split]


let rec check_all_splits t constraints =
    match t with 
    | Leaf _ -> true
    | Node (split, _, left, right) -> 
        check_split split constraints 
        && check_all_splits left constraints
        && check_all_splits right constraints

let rec induct_scheme_node tableau ubs lbs cs x tree =
    match tree with
    | Leaf _ -> true
    | Node (split, _, left, right) ->
        let (lb_left, ub_left), (lb_right, ub_right) = update_bounds_from_split lbs ubs split in
        induct_scheme_node tableau ub_left lb_left cs x left 
        && induct_scheme_node tableau ub_right lb_right cs x right
        (* induct_scheme_node tableau ubs lbs cs x right *)
        (* && induct_scheme_node tableau ubs lbs cs x left *)
[@@disable update_bounds_from_split]

lemma soundness_node_unsat_matching tableau upper_bounds lower_bounds constraints x tree =
    check_all_splits tree constraints
    ==>
    match tree with
    | Leaf _ -> true
    | Node (split, bound_lemmas, left, right) ->
        check_node (mk_eq_constraints tableau) upper_bounds lower_bounds constraints tree
        ==>
        unsat tableau upper_bounds lower_bounds constraints x
    [@@by induct ~on_fun:[%id induct_scheme_node] ()
        @> [%use unsat_not_sat tableau upper_bounds lower_bounds constraints x]
        @> auto]
    [@@disable sat, check_node, mk_eq_constraints]
    [@@fc]

(* lemma check_node_soundness (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list) 
        (constraints: Constraint.t list) (tree: Proof_tree.t) (x: real list) =
    (* this is a check performed in check_proof_tree, outside of check_node *)
    well_formed_tableau_bounds tableau upper_bounds lower_bounds
    && List.length x = List.length (List.hd tableau)
    && check_all_splits tree constraints
    && check_node (mk_eq_constraints tableau) upper_bounds lower_bounds constraints tree
    ==>
    unsat tableau upper_bounds lower_bounds constraints x
    [@@by [%use soundness_leaf tableau upper_bounds lower_bounds constraints x tree]
       @> [%use check_node_parent_imply_check_node_children (mk_eq_constraints tableau) upper_bounds lower_bounds constraints tree]
       @> induct ~on_fun:[%id check_node] ()]
    [@@disable update_bounds, unsat, Checker.well_formed_tableau_bounds, List.length, Checker.check_node]
    [@@timeout 30] *)
