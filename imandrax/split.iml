(* GP Status: PROVED! *)

[@@@import "util.iml"]
[@@@import "tightening.iml"]
[@@@import "constraint.iml"]

open Util
open Tightening
open Constraint

type t = 
    SingleSplit of int * real (* variable, value *)
    | ReluSplit of int * int * int (* participating relu variables: b, f, aux *) 
    | Invalid

let is_single_var (split: t): bool =
    match split with
    | SingleSplit _ -> true
    | _ -> false

let is_relu (split: t): bool =
    match split with
    | ReluSplit _ -> true
    | _ -> false

let is_invalid (split: t): bool =
    match split with
    | Invalid -> true
    | _ -> false

(* check that some split corresponds to a single variable split *)
let match_single_var_split (l_t: Tightening.t list) (r_t: Tightening.t list): t =
    match l_t, r_t with
    | [(var1, value1, UPPER)], [(var2, value2, LOWER)]
    | [(var1, value1, LOWER)], [(var2, value2, UPPER)] -> 
        if var1 = var2 && value1 = value2
        then SingleSplit (var1, value1)
        else Invalid
    | _, _ -> Invalid

let check_single_var_split (l_t: Tightening.t list) (r_t: Tightening.t list): bool = 
    match match_single_var_split l_t r_t with 
    | SingleSplit _ -> true
    | _ -> false 

let is_single_var (split: t): bool =
    match split with
    | SingleSplit _ -> true
    | _ -> false

let is_relu (split: t): bool =
    match split with
    | ReluSplit _ -> true
    | _ -> false

let is_invalid (split: t): bool =
    match split with
    | Invalid -> true
    | _ -> false

let update_bounds_from_split (lbs: real list) (ubs: real list) (split: t): 
        ((real list * real list) * (real list * real list)) =
    match split with
    | SingleSplit (i, k) -> ((set_nth lbs i k, ubs), (lbs, set_nth ubs i k))
    | ReluSplit (b, f, aux) ->
        ((set_nth lbs f 0.,  set_nth (set_nth ubs b 0.) f 0.), (set_nth (set_nth lbs b 0.) aux 0., set_nth ubs aux 0.))
        (* let lbs' = set_nth lbs f 0. in
        let ubs' = set_nth (set_nth ubs b 0.) f 0. in
        let lbs'' = set_nth (set_nth lbs b 0.) aux 0. in
        let ubs'' = set_nth ubs aux 0. in
        (lbs', ubs'), (lbs'', ubs'') *)
    | _ -> (lbs, ubs), (lbs, ubs)

let match_relu_split_measure constraints =
    Ordinal.of_int (List.length constraints)

let parse_relu_split l_tightenings r_tightenings: t =
    match l_tightenings, r_tightenings with
    [(x1, 0., t1); (x2, 0., t2)], [(x3, 0., t3); (x4, 0., t4)] -> (
        (* inactive phase, active phase *)
        (* x1 = b, x2 = f, x3 = b, x4 = aux *)
        if (x1 = x3 && t1 = UPPER && t2 = UPPER && t3 = LOWER && t4 = UPPER) then ReluSplit (x1,x2,x4)
        (* x1 = f, x2 = b, x3 = b, x4 = aux *)
        else if (x2 = x3 && t1 = UPPER && t2 = UPPER && t3 = LOWER && t4 = UPPER) then ReluSplit (x2,x1,x4)
        (* x1 = b, x2 = f, x3 = aux, x4 = b *)
        else if (x1 = x3 && t1 = UPPER && t2 = UPPER && t4 = LOWER && t3 = UPPER) then ReluSplit (x1,x2,x3)
        (* x1 = f, x2 = b, x3 = aux, x4 = b *)
        else if (x2 = x4 && t1 = UPPER && t2 = UPPER && t4 = LOWER && t3 = UPPER) then ReluSplit (x2,x1,x3)
        (* active phase, inactive phase *)
        (* x1 = b, x2 = aux, x3 = b, x4 = f *)
        else if (x1 = x3 && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) then ReluSplit (x1,x4,x2)
        (* x1 = aux, x2 = b, x3 = b, x4 = f *)
        else if (x1 = x3 && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) then ReluSplit (x1,x4,x2)
        (* x1 = b, x2 = aux, x3 = f, x4 = b *)
        else if (x1 = x3 && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) then ReluSplit (x1,x4,x2)
        (* x1 = aux, x2 = b, x3 = f, x4 = b *)
        else if (x1 = x3 && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) then ReluSplit (x1,x4,x2)
        else Invalid
        )
        | _ -> Invalid 

let is_relu_split b f aux l_tightenings r_tightenings: bool =
    match l_tightenings, r_tightenings with
    [(x1, 0., t1); (x2, 0., t2)], [(x3, 0., t3); (x4, 0., t4)] -> (
        (* inactive phase, active phase *)
        (* x1 = b, x2 = f, x3 = b, x4 = aux *)
        (x1 = b && x2 = f && x3 = b && x4 = aux && t1 = UPPER && t2 = UPPER && t3 = LOWER && t4 = UPPER) 
        (* x1 = f, x2 = b, x3 = b, x4 = aux *)
        || (x1 = f && x2 = b && x3 = b && x4 = aux && t1 = UPPER && t2 = UPPER && t3 = LOWER && t4 = UPPER) 
        (* x1 = b, x2 = f, x3 = aux, x4 = b *)
        || (x1 = b && x2 = f && x3 = aux && x4 = b && t1 = UPPER && t2 = UPPER && t4 = LOWER && t3 = UPPER) 
        (* x1 = f, x2 = b, x3 = aux, x4 = b *)
        || (x1 = f && x2 = b && x3 = aux && x4 = b && t1 = UPPER && t2 = UPPER && t4 = LOWER && t3 = UPPER) 
        (* active phase, inactive phase *)
        (* x1 = b, x2 = aux, x3 = b, x4 = f *)
        || (x1 = b && x2 = aux && x3 = b && x4 = f && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) 
        (* x1 = aux, x2 = b, x3 = b, x4 = f *)
        || (x1 = aux && x2 = b && x3 = b && x4 = f && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) 
        (* x1 = b, x2 = aux, x3 = f, x4 = b *)
        || (x1 = b && x2 = aux && x3 = f && x4 = b && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER) 
        (* x1 = aux, x2 = b, x3 = f, x4 = b *)
        || (x1 = aux && x2 = b && x3 = f && x4 = b && t1 = LOWER && t2 = UPPER && t3 = UPPER && t4 = UPPER))
        | _ -> false 

let rec match_relu_split (l_t: Tightening.t list) (r_t: Tightening.t list) (constraints: Constraint.t list): t = 
    match constraints with
    | [] -> Invalid 
    | Relu (b, f, aux)::tl -> 
        if is_relu_split b f aux l_t r_t
        then ReluSplit (b, f, aux)
        else match_relu_split r_t l_t tl
    | _::tl -> match_relu_split r_t l_t tl
[@@measure match_relu_split_measure constraints]

let match_split (l_t: Tightening.t list) (r_t: Tightening.t list) (constraints: Constraint.t list): t =
    match (match_single_var_split l_t r_t) with 
    | SingleSplit (var, value) -> SingleSplit (var, value)  
    | _ -> (
        match (match_relu_split l_t r_t constraints) with
        | ReluSplit (b, f, aux) -> ReluSplit (b, f, aux)
        | _ -> Invalid
    )

(* Match a given split with a constraint from a list of known ReLU constraints*)
let rec match_relu_constraint r_tightening l_tightening constraints =
    match constraints with
    | [] -> []
    | (RELU, l)::tl-> (
        match r_tightening, l_tightening with
        | [(var1, _, _); (var2, _, _)], [(var3, _, _); (var4, _, _)] ->
            if
                List.exists (fun x -> x = var1) l &&
                List.exists (fun x -> x = var2) l &&
                List.exists (fun x -> x = var3) l &&
                List.exists (fun x -> x = var4) l
            then
                l
            else
                match_relu_constraint r_tightening l_tightening tl
        | _ -> match_relu_constraint r_tightening l_tightening tl
    )
    | (_::tl) -> match_relu_constraint r_tightening l_tightening tl

(* find a constraint given two participating variables *)
(* let rec match_constraint (var1: int) (var2: int) (constraints: Constraint.t_old list): (Constraint.t_old) =
    match constraints with
    | [] -> (UNDEFINED, [])
    (* | Relu (b,f,a)::tl-> *)
    | (RELU, [f;b;a]) :: tl ->
            if (b = var1 && f = var2) || (f = var1 && b = var2)
            then (RELU, [b;f;a])
            else match_constraint var1 var2 tl
    | _ -> (UNDEFINED, [])
 *)
let rec match_constraint (var1: int) (var2: int) constraints =
    match constraints with
    | [] -> (UNDEFINED, [])
    | (c, l)::tl->
            if List.exists (fun x -> x = var1) l && List.exists (fun x -> x = var2) l
            then (c, l)
            else match_constraint var1 var2 tl

(* check that the split corresponds to the active phase of a ReLU constraint *)
let is_active split b aux = match split with
    | [(var1, 0., UPPER); (var2, 0., LOWER)] -> var1 = aux && var2 = b
    | [(var1, 0., LOWER); (var2, 0., UPPER)] -> var1 = b && var2 = aux
    | _ -> false

(* check that the split corresponds to the inactive phase of a ReLU constraint *)
let is_inactive split f b = match split with
    | [(var1, 0., UPPER); (var2, 0., UPPER)] -> (var1 = f && var2 = b) || (var1 = b && var2 = f)
    | _ -> false

(* Check whether a proof tree node's split correspond to a known ReLU constraint *)
let check_relu_split (l_tightening : Tightening.t list) (r_tightening : Tightening.t list) (constraints: Constraint.t_old list) =
    let matched_constraint = match_relu_constraint l_tightening r_tightening constraints in
    match matched_constraint with
        | [b; f; aux; _] -> (is_active l_tightening b aux && is_inactive r_tightening f b) || (is_active r_tightening b aux && is_inactive l_tightening f b)
        | _ -> false