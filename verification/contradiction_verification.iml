#logic;;
let rec is_bounded (vars: real list) (upper_bounds: real list) (lower_bounds: real list) =
  match vars, upper_bounds, lower_bounds with
        | [], [], [] -> true
        | x::xs, u::us, l::ls ->
            if x >=. l && x <=. u
            then is_bounded xs us ls
            else false
        | _ -> false

let rec dot_product x  y =
        match x, y with
        | [], [] -> 0.
        | x1::xs, y1::ys -> x1 *. y1 +. (dot_product xs ys)
        | _ -> 0. (* TODO handle error case *)


axiom dot_product_symmetry x y =
    dot_product x y = dot_product y x
    [@@auto][@@rw]

let rec null_product (tableau: real list list) (x: real list) =
    match tableau, x with
    | [], [] -> true
    | row::tl, _ -> dot_product row x = 0. && (null_product tl x)
    | _ -> false

lemma zero_dot_product_r x tableau row =
    dot_product row x = 0. && null_product tableau x
    ==> null_product (tableau @ [row]) x = true
[@@auto][@@rw]

lemma zero_dot_product_l x tableau row =
    dot_product row x = 0. && null_product tableau x
    ==> null_product (row::tableau) x = true
[@@auto][@@rw]

(* axiom zero_dot_product_mult row x c =
    dot_product x row = 0. 
    ==>
    dot_product x (List.map (fun a -> c *. a) row) = 0. *)
(*[@@disable List.map, dot_product][@@auto]*)

lemma l1 x = 
    x <> []
    ==>
    repeat 0. (List.length x) <> []
[@@auto]

lemma update_combination_id x =
    update_combination 1. x (repeat 0. (List.length x)) = x
[@@auto][@@apply l1 x]

lemma update_combination_zero_vec c x =
    update_combination c x (repeat 0. (List.length x)) = List.map (( *. ) c) x
[@@auto]


lemma update_combination_nonempty y z n = 
    List.length y = List.length z && y <> []
    ==>
    (update_combination n y z) <> []
[@@auto]

let rec pred y z r = match y, z, r with
| [], [], [] -> true   
| y_hd::y_tl, z_hd::z_tl, r_hd::r_tl -> y_hd +. z_hd = r_hd && pred y_tl z_tl r_tl
| _, _, _ -> false

lemma update_combination_coeff_1 y z =
    let r = update_combination 1. y z in
    List.length y = List.length z 
    ==>
    pred y z r
[@@auto]
   
lemma list_mult_length_preservation y c = 
    List.length y = List.length (list_mult y c)
[@@auto]

lemma vectors_distrib x y c = 
    list_add (list_mult x c) (list_mult y c) = list_mult (list_add x y) c
[@@auto]

lemma list_add_identity x =
    let zeros = repeat 0. (List.length x) in
    list_add x zeros = x
[@@auto]

lemma dot_product_zero x = 
    let zeros = repeat 0. (List.length x) in
    dot_product x zeros = 0.
[@@auto]

lemma dot_product_coeff x y c =
    dot_product x (list_mult y c) = c *. dot_product x y
[@@auto]


lemma dot_prod_coeff_eq x y c = 
    dot_product x y = 0.
    ==>
    dot_product x (list_mult y c) = 0.
[@@auto][@@apply dot_product_coeff x y c]

lemma dot_product_add x y z  =
    List.length x = List.length y &&
    List.length x = List.length z
    ==>
    (dot_product x y) +. (dot_product x z) = dot_product x (list_add y z)
[@@auto]

lemma kernel_vector_for_any_row tableau x row =
    null_product tableau x && List.mem row tableau
    ==> dot_product row x = 0.
[@@disable null_product, dot_product][@@auto]

let kernel_vector_for_any_combination tableau x y =
    null_product tableau x
    ==> dot_product x (compute_combination y tableau) = 0.

verify kernel_vector_for_any_combination
[@@disable null_product, dot_product][@@auto]

(*
lemma bounds_combination row x upper_bounds lower_bounds c =
    compute_row_upper_bound row upper_bounds lower_bounds = c
    <==> (is_bounded x upper_bounds lower_bounds
         && dot_product x row <=. c) = true

lemma contradiction_implies_negative_row x y tableau upper_bounds lower_bounds =
         check_contradiction y tableau upper_bounds lower_bounds
         <==> (is_bounded x upper_bounds lower_bounds
         && dot_product x y <. 0.) = true
     [@@auto]

lemma contradiction_implies_negative_row x y tableau upper_bounds lower_bounds =
    (check_contradiction y tableau upper_bounds lower_bounds [@trigger rw] &&
     is_bounded x upper_bounds lower_bounds) ==>
    dot_product x (compute_combination y tableau (M.empty)) <. 0. = true
[@@auto] [@@rw]


axiom dot_product_check_contradiction_eq x y tableau upper_bounds lower_bounds =
    is_bounded x upper_bounds lower_bounds &&
    dot_product x (compute_combination y tableau) <. 0. ==>
    check_contradiction y tableau upper_bounds lower_bounds = true
;;

theorem contradiction_verification x contradiction tableau upper_bounds lower_bounds =
    is_bounded x upper_bounds lower_bounds &&
    check_contradiction contradiction tableau upper_bounds lower_bounds ==>
    not (null_product tableau x)
[@@auto][@@apply dot_product_check_contradiction_eq x contradiction tableau upper_bounds lower_bounds]
[@@disable dot_product, is_bounded, check_contradiction]
;; *)
