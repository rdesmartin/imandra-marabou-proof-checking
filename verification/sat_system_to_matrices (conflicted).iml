(* 
  Proof that the satisfiability of the system representation implies the 
  satisfiability of the matrix representation of a linear query:
  If an assignment x satisfies the system representation of the 
  query (tableau, upper_bounds, lower_bounds), then x also satisfies the
  matrix representation.
*)

open Utils
open Constraint
open Certificate
open Arithmetic
open Farkas_lemma

(* =============== Eq constraints ================================ *)

lemma eval_tableau_row_poly row x = 
    eval_poly (row @ [0.]) x = dot_product row x
    [@@auto]
    [@@rw]

lemma mk_eq_constraints_implies_is_in_kernel tableau x =
    eval_system (mk_eq_constraints tableau) x
    ==>
    is_in_kernel tableau x
    [@@auto]
    [@@fc]

lemma full_system_implies_eq_constraints tableau upper_bounds lower_bounds x =
    eval_system (mk_system_contradiction (mk_eq_constraints tableau) upper_bounds lower_bounds) x
    ==>
    eval_system (mk_eq_constraints tableau) x
    [@@auto]
    [@@fc]

lemma eval_system_implies_is_in_kernel tableau upper_bounds lower_bounds x =
    eval_system (mk_system_contradiction (mk_eq_constraints tableau) upper_bounds lower_bounds) x
    ==>
    is_in_kernel tableau x
    [@@auto]
    [@@disable Certificate.mk_system_contradiction]
    [@@fc]

(* ================ Geq constraints =============================== *)

axiom mk_lb_constraints_implies_is_upper_bounded lower_bounds x =
    eval_system (mk_lower_bounds_constraints (List.length lower_bounds) lower_bounds) x
    ==>
    is_upper_bounded lower_bounds x
    [@@fc]

let is_bounded_at i ubs xs = 
    match (List.nth i xs), (List.nth i ubs) with
    | Some x, Some u -> x <=. u
    | _, _ -> false

lemma eval_mk_bound_poly_implies_bounded_at_i i x ubs u =
    0 <= i && i < List.length x && x <> [] &&
    List.nth i ubs = Some u &&
    eval_exp (Geq (mk_bound_poly (List.length x) i (-1.) u)) x
    ==>
    is_bounded_at i ubs x
    [@@auto]
    [@@fc]

lemma bounds_i_j j lu lx =
    let i = lx - lu + j in
    0 <= j && j < lu &&
    0 < lu && lu <= lx
    ==>
    0 <= i && i < lx
    [@@auto]
    [@@fc]

lemma eval_mk_bound_poly_implies_bounded_at x ubs u j =
    let lx = List.length x in
    let lu = List.length ubs in
    let i = lx - lu + j in
    0 <= j && j < lu &&
    0 < lu && lu <= lx &&
    List.nth i ubs = Some u &&
    eval_exp (Geq (mk_bound_poly lx i (-1.) u)) x
    ==>
    is_bounded_at i ubs x
    [@@auto]
    [@@disable is_bounded_at]
    [@@apply bounds_i_j j (List.length ubs) (List.length x),
        eval_mk_bound_poly_implies_bounded_at_i ((List.length x) - (List.length ubs) + j) x ubs u]
    [@@fc]

lemma eval_system_element s e i x =
    List.nth i s = Some e &&
    eval_system s x
    ==>
    eval_exp e x
    [@@auto]
    [@@fc]
    
(*
lemma eval_system_up_to_element s e i x =
    List.nth i s = Some e &&
    eval_system_up_to s (List.length s - 1) x
    ==>
    eval_exp e x
    [@@auto]
    [@@fc] *)

lemma eval_ub_system_implies_eval_exp_ith x ubs u i =
    List.length x = List.length ubs &&
    x <> [] &&
    List.nth i ubs = Some u &&
    0 <= i && i < List.length x &&
    eval_system (mk_upper_bounds_constraints (List.length x) ubs) x 
    ==>
    match List.nth i (mk_upper_bounds_constraints (List.length x) ubs) with
    | Some e -> eval_exp e x
    | None -> false
    [@@auto]
    [@@apply parallel_nth_generalized ubs i u (List.length x)]
    [@@disable Farkas_lemma.eval_exp, is_bounded_at]
    [@@fc]


lemma eval_ub_system_implies_eval_exp_ith_destruct x ubs u i =
    let size = List.length x in
    List.length x = List.length ubs &&
    x <> [] &&
    List.nth i ubs = Some u &&
    0 <= i && i < List.length x &&
    eval_system (mk_upper_bounds_constraints size ubs) x 
    ==>
    eval_exp (Geq (mk_bound_poly size (size - List.length ubs + i) (-1.) u)) x
    [@@auto]
    [@@apply parallel_nth_generalized ubs i u (List.length x), 
        eval_ub_system_implies_eval_exp_ith x ubs u i]
    [@@disable Farkas_lemma.eval_exp]
    [@@fc]

lemma eval_ub_system_implies_bounded_at x ubs u i =
    List.length x = List.length ubs &&
    x <> [] &&
    List.nth i ubs = Some u &&
    0 <= i && i < List.length x &&
    eval_system (mk_upper_bounds_constraints (List.length x) ubs) x 
    ==>
    is_bounded_at i ubs x
    [@@auto]
    [@@apply eval_ub_system_implies_eval_exp_ith_destruct x ubs u i,
        eval_mk_bound_poly_implies_bounded_at x ubs u i]
    [@@disable Farkas_lemma.eval_exp]
    [@@fc]

lemma eval_ub_system_implies_bounded_at_hd x ubs =
    List.length x = List.length ubs &&
    x <> [] &&
    eval_system (mk_upper_bounds_constraints (List.length x) ubs) x 
    ==>
    (* List.hd ubs >=. List.hd x *)
    match ubs, x with
    | u :: ubs, x :: xs -> u >=. x
    | _, _ -> false
    [@@auto]
    [@@apply eval_ub_system_implies_bounded_at x ubs (List.hd ubs) 0]
    [@@disable Farkas_lemma.eval_exp]
    [@@fc]

lemma tail_length l = l <> [] ==> (1 + List.length (List.tl l)) = List.length l
[@@rw]

lemma length_tl_eq l1 l2 = 
    l1 <> [] && l2 <> [] &&
    List.length (List.tl l1) = List.length (List.tl l2)
    ==> 
    List.length l1 = List.length l2
[@@auto]
[@@fc]

(* 
lemma ad_hoc_helper_1_3 x ubs =
    x <> [] && List.length x = List.length ubs &&
    eval_exp (Geq (mk_bound_poly (List.length x) (List.length x - List.length ubs) (-1.) (List.hd ubs))) x
    ==>
    List.hd x <=. List.hd ubs
    [@@auto]
    [@@fc]

lemma ad_hoc_helper_1_4 x ubs = 
    List.length (List.tl x) = List.length ubs - 1 && x <> [] &&
    eval_system (mk_upper_bounds_constraints (1 + List.length (List.tl x)) ubs) x 
    ==> 
    List.hd x <=. List.hd ubs
    [@@auto]
    [@@apply eval_ub_system_implies_bounded_at_hd x ubs, tail_length x]
    [@@fc]

lemma ad_hoc_helper_1_3' x ubs = 
    List.length x = List.length ubs && x <> [] &&
    eval_system (mk_upper_bounds_constraints (1 + List.length (List.tl x)) ubs) x 
    ==> 
    List.hd x <=. List.hd ubs
    [@@auto]
    [@@apply eval_ub_system_implies_bounded_at_hd x ubs, tail_length x]
    [@@fc]

lemma ad_hoc_helper_1_1 x ubs =
    eval_system (mk_upper_bounds_constraints (List.length x) ubs) x
    ==>
    eval_system (mk_upper_bounds_constraints (List.length (List.tl x)) (List.tl ubs)) (List.tl x)
    [@@auto]
     *)

let rec bounded_down_from x ubs i = 
    if i < 0 || i >= List.length x then true
    else is_bounded_at i ubs x &&
        bounded_down_from x ubs (i - 1)

let all_bounds_correct x ubs =
    bounded_down_from x ubs (List.length x - 1)

lemma upper_bounded_correct x ubs =
    is_upper_bounded x ubs
    ==>
    all_bounds_correct x ubs
    [@@auto]
    [@@induct functional Arithmetic.is_upper_bounded]

lemma mk_ub_constraints_implies_bounded_up_to x ubs i =
    0 <= i && i < List.length x &&
    List.length x = List.length ubs && x <> [] &&
    eval_system_up_to (mk_upper_bounds_constraints (List.length x) ubs) i x
    ==>
    bounded_up_to x ubs i
    [@@auto]
    [@@disable is_bounded_at, List.length]
    [@@induct functional bounded_up_to]
    [@@fc]

lemma bounded_up_to_implies_upper_bounded ubs x =
    List.length x = List.length ubs && x <> [] &&
    bounded_up_to x ubs (List.length x - 1) 
    ==>
    is_upper_bounded x ubs
    [@@auto]

(* current VG: *)
lemma mk_ub_constraints_implies_is_upper_bounded ubs x =
    List.length x = List.length ubs && x <> [] &&
    eval_system (mk_upper_bounds_constraints (List.length x) ubs) x
    ==>
    is_upper_bounded x ubs
    [@@auto]
    [@@induct functional Arithmetic.is_upper_bounded]
    [@@disable Farkas_lemma.eval_exp, tail_length]
    [@@fc]

lemma eval_system_concat_destruct s1 s2 x =
    eval_system (s1 @ s2) x
    ==>
    eval_system s1 x && eval_system s2 x
    [@@auto]
    [@@fc]

lemma mk_geq_constraints_implies_is_bounded upper_bounds lower_bounds x =
    List.length x = List.length upper_bounds &&    
    List.length lower_bounds = List.length upper_bounds &&
    eval_system (mk_geq_constraints upper_bounds lower_bounds) x
    ==>
    is_upper_bounded x upper_bounds && is_upper_bounded lower_bounds x
    [@@auto]
    [@@disable Farkas_lemma.eval_system]
    [@@fc]

lemma full_system_implies_geq_constraints tableau upper_bounds lower_bounds x =
    eval_system (mk_system_contradiction (mk_eq_constraints tableau) upper_bounds lower_bounds) x
    ==>
    eval_system (mk_geq_constraints upper_bounds lower_bounds) x
[@@auto]
[@@fc]

lemma eval_system_implies_is_bounded tableau upper_bounds lower_bounds x =
    well_formed_tableau tableau &&
    eval_system (mk_system_contradiction (mk_eq_constraints tableau) upper_bounds lower_bounds) x
    ==>
    is_bounded upper_bounds lower_bounds x
    [@@auto]
    [@@disable Arithmetic.is_bounded]
    [@@fc]

(* ================= Main theorem ===================== *)
    
theorem eval_system_implies_sat tableau upper_bounds lower_bounds relu_constraints x =
    well_formed_tableau tableau &&
    eval_system (mk_system_contradiction (mk_eq_constraints tableau) upper_bounds lower_bounds) x
    ==>
    is_in_kernel tableau x &&
    is_bounded upper_bounds lower_bounds x
    [@@auto]
    [@@disable Certificate.mk_system_contradiction]