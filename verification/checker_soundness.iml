open Utils
open Constraint
open Proof_tree
open Check_splits
open Certificate
open Checker
open Arithmetic

let check_relu_constraints = Constraint.check_relu_constraints

let unsat tableau upper_bounds lower_bounds relu_constraints x =
    (is_in_kernel tableau x &&
    is_bounded upper_bounds lower_bounds x &&
    check_relu_constraints relu_constraints x) = false

let sat tableau upper_bounds lower_bounds relu_constraints x =
    (is_in_kernel tableau x &&
    is_bounded upper_bounds lower_bounds x &&
    check_relu_constraints relu_constraints x)

let unsat_rw tableau upper_bounds lower_bounds relu_constraints x =
    unsat tableau upper_bounds lower_bounds relu_constraints x = not (sat tableau upper_bounds lower_bounds relu_constraints x )
    [@@rw]


(* 
    TODO: these might be assumptions we need:
        let sanity_check_res = sanity_checks tableau upper_bounds lower_bounds in
        let tableau_system = mk_eq_constraints tableau in

    | ProofTree.Node ([], bound_lemmas, _, _) | ProofTree.Leaf ([], bound_lemmas, _) ->
 *)
 axiom soundness_leaf tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Node _ -> true
    | (Leaf contradiction) ->
        check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree
        ==> 
        unsat tableau upper_bounds lower_bounds relu_constraints x
    [@@fc]

(* This states that if a node is sat, then one of its children is sat -> version of this proved in `split_invariant.iml` *)
axiom invariant_relu_split_sat tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) ->
        let (_, ub_left, lb_left) = Checker.update_child_bounds left (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints in
        let (_, ub_right, lb_right) = Checker.update_child_bounds right (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints in
        check_children_splits left.tightenings right.tightenings relu_constraints &&
        sat tableau upper_bounds lower_bounds relu_constraints x
        ==>
        sat tableau ub_left lb_left relu_constraints x ||
        sat tableau ub_right lb_right relu_constraints x
    [@@fc]

(* This states that if at least one child of a node is sat, then `check_node` is false -> is this 
something we proved? If not, how do we prove this? *)
axiom sat_child_implies_not_check_node tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) ->
        let (_, ub_left, lb_left) = Checker.update_child_bounds left (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints in
        let (_, ub_right, lb_right) = Checker.update_child_bounds right (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints in
        check_children_splits left.tightenings right.tightenings relu_constraints &&
        (* From check_node, we have that check_node tableau ub_left lb_left constraints left.ptr) &&
            (check_node tableau ub_right lb_right constraints right.ptr *)
        (sat tableau ub_left lb_left relu_constraints x ||
        sat tableau ub_right lb_right relu_constraints x)
        ==>
        not (check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree)
    [@@fc]

lemma soundness_check_node_contra_valid_split tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) -> 
        check_children_splits left.tightenings right.tightenings relu_constraints &&
        sat tableau upper_bounds lower_bounds relu_constraints x
        ==>
        not (check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree)
    [@@auto]
    [@@disable sat, Checker.check_node, Checker.check_children_splits]
    [@@apply invariant_relu_split_sat tableau upper_bounds lower_bounds relu_constraints x proof_tree,
        sat_child_implies_not_check_node tableau upper_bounds lower_bounds relu_constraints x proof_tree]
    [@@fc]

lemma soundness_check_node_contra_invalid_split tableau upper_bounds lower_bounds relu_constraints proof_tree = 
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) -> 
        not (check_children_splits left.tightenings right.tightenings relu_constraints)
        ==>
        not (check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree)
    [@@auto]
    [@@disable Checker.check_node, Checker.check_children_splits]
    [@@fc]

lemma soundness_node_contra tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) ->
        sat tableau upper_bounds lower_bounds relu_constraints x
        ==>
        not (check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree)
    [@@auto]
    [@@disable sat, Checker.update_child_bounds]
    [@@apply ]
    [@@fc]

lemma soundness_node tableau upper_bounds lower_bounds relu_constraints x proof_tree =
    let open ProofTree in
    match proof_tree with
    | Leaf _ -> true
    | Node (left, right) ->
        check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree
        ==>
        not (sat tableau upper_bounds lower_bounds relu_constraints x)
    [@@auto]
    [@@disable sat, Checker.check_node, Certificate.mk_eq_constraints]
    [@@fc]

lemma check_node_soundness (tableau: real list list) (upper_bounds: real list) (lower_bounds: real list) 
        (relu_constraints: Constraint.t list) (proof_tree: ProofTree.t) (x: real list) =
    check_node (mk_eq_constraints tableau) upper_bounds lower_bounds relu_constraints proof_tree
    ==>
    unsat tableau upper_bounds lower_bounds relu_constraints x
    [@@auto]
    [@@simp]
    [@@induct structural proof_tree]
    [@@apply soundness_leaf tableau upper_bounds lower_bounds relu_constraints x proof_tree,
        soundness_node tableau upper_bounds lower_bounds relu_constraints x proof_tree]