open Utils
open Arithmetic.LinArith
open Constraint
open Proof_tree
open Checker
open Check_splits
open Certificate
open Farkas_lemma
open Tightening
open Bound_lemma

(** Return true if the variable vector x is a solution to the tableau *)
let is_solution (tableau: real list list) (x: real list) : bool =
    Utils.all (List.map (fun row -> dot_product row x = 0.) tableau)

let valid_split (node: ProofTree.t) (q: query) = 
    match node with
    | Leaf _ -> true
    | Node (tightenings, bound_lemma, children) ->
        check_children_splits children q.constraints

lemma valid_split_lm node (q: query) =
    check_node q.tableau q.upper_bounds q.lower_bounds q.constraints node
    ==>
    valid_split node q

lemma tighten_invariant tightenings upper_bounds lower_bounds = 
    tightenings = [] 
    ==> 
    Tightening.update_bounds tightenings upper_bounds lower_bounds = (upper_bounds, lower_bounds)
    [@@rw][@@fc]

lemma bound_lemma_invariant bound_lemmas tableau upper_bounds lower_bounds constraints = 
    bound_lemmas = []
    ==>
    BoundLemma.check_bound_lemmas bound_lemmas tableau upper_bounds lower_bounds constraints = (true, upper_bounds, lower_bounds)
    [@@rw][@@fc]

(** Lemmas about well-formedness and system -tableau dimensions correspondence *)

(** well_formed_mk_eq_constraints  *)
lemma well_formed_helper row =
    good_poly_length (List.append row [0.]) row
    [@@auto]
    [@@rw][@@fc]

let rec well_formed_tableau' tableau size = 
    match tableau with
    | hd :: tl -> List.length hd = size && well_formed_tableau' tl size
    | [] -> true

let well_formed_tableau tableau = 
    tableau <> [] &&
    List.hd tableau <> [] && 
    well_formed_tableau' tableau (List.length (List.hd tableau))

lemma well_formed_helper2 row tableau =
    tableau <> [] && List.hd tableau = [] &&
    row <> []
    ==>
    well_formed_tableau' tableau (List.length row) = false
    [@@auto]
    [@@rw][@@fc]

lemma wf_tableau_eq tableau r = 
    well_formed_tableau tableau &&
    List.mem r tableau
    ==> 
    List.length r = List.length (List.hd tableau)
[@@auto]
[@@fc]

lemma good_poly_length_eq_constraints tableau system =
    well_formed_tableau tableau &&
    system = mk_eq_constraints tableau
    ==> 
    good_poly_length (extract_poly (List.hd system)) (List.hd tableau)
    [@@auto]
    [@@fc]

lemma wf_tableau_not_empty tableau r = 
    well_formed_tableau tableau &&
    List.mem r tableau
    ==> 
    r <> []
[@@auto]
[@@fc]

lemma mk_eq_constraints_non_empty tableau = 
    tableau <> [] 
    ==> 
    mk_eq_constraints tableau <> []
    [@@rw][@@fc]

lemma well_formed_tableau_helper3 tableau1 tableau2 =
    tableau2 <> [] &&
    well_formed_tableau' tableau2 (List.length tableau1)
    ==>
    List.length (List.hd tableau2) = List.length tableau1
    [@@auto]
    [@@fc]

lemma well_formed_tableau_helper5 p x1 x2 = 
    List.length x1 = List.length x2 
    && good_poly_length p x1 
    ==> 
    good_poly_length p x2
    [@@auto]
    [@@fc]

lemma well_formed_tableau_helper4 tableau l1 l2 =
    List.length l1 = List.length l2 &&
    well_formed_tableau tableau &&
    well_formed (mk_eq_constraints tableau) l1
    ==>
    well_formed (mk_eq_constraints tableau) l2
    [@@auto]
    [@@fc]

lemma wf_tableau_append tableau row =
    well_formed_tableau tableau && well_formed_tableau [row] && List.length (List.hd tableau) = List.length row
    ==> 
    well_formed_tableau (row :: tableau)
    [@@disable List.map, List.length, Utils.all]
    [@@auto]

let rec induction_scheme tableau system =
    match tableau, system with
    | ht::tt, hs::ts -> induction_scheme tt ts
    | [], [] -> true
    | _, _ -> true

lemma well_formed_mk_eq_constraints tableau system =
    well_formed_tableau tableau &&
    system = mk_eq_constraints tableau
    ==>
    well_formed system (List.hd tableau)
[@@disable List.map, List.length, Utils.all]
[@@induct functional induction_scheme]

(** well_formed_mk_geq_constraints *)

lemma mk_bound_poly_size p size i coeff bound =
    size >= 0 &&
    p = mk_bound_poly size i coeff bound
    ==> 
    List.length p = size + 1
    [@@auto]
    [@@fc]

lemma mk_geq_poly_size p c u l i size = 
    size >= 0 &&
    p = mk_geq_poly c u l i size
    ==> 
    List.length p = size + 1
    [@@auto]
    [@@fc]

lemma good_poly_length_helper p x =
    List.length p = (List.length x) + 1
    ==>
    good_poly_length p x
    [@@auto]
    [@@rw][@@fc]

let rec induction_scheme_geq coeffs upper_bounds lower_bounds i size system = 
    match coeffs, upper_bounds, lower_bounds, system with
    | c :: cs, u :: us, l :: ls, s :: ss -> induction_scheme_geq cs us ls i size ss
    | [], [], [], [] -> true
    | _ -> true

lemma well_formed_mk_geq_constraints_helper1 c u l i size poly x =
    poly = mk_geq_poly c u l i size &&
    List.length x = size
    ==>
    good_poly_length poly x
[@@auto]
[@@apply good_poly_length_helper poly x]
[@@disable Certificate.mk_geq_poly]
[@@fc]


lemma well_formed_mk_geq_constraints_helper2 c u l i size poly x =
    poly = mk_geq_poly c u l i size &&
    List.length x = size
    ==>
    well_formed [Geq poly] x
[@@auto]
[@@apply well_formed_mk_geq_constraints_helper1 c u l i size poly x]
[@@disable Certificate.mk_geq_poly]

let is_geq p = match p with
    | Geq _ -> true
    | _ -> false

lemma mk_geq_constraints_is_geq c u l i size =
    c <> [] && u <> [] && l <> [] 
    ==>
    is_geq (List.hd (mk_geq_constraints' c u l i size))
    [@@auto]
    [@@fc]

lemma well_formed_mk_geq_constraints_head coeffs upper_bounds lower_bounds i size system l =
    system = mk_geq_constraints' coeffs upper_bounds lower_bounds i size &&
    coeffs <> [] && upper_bounds <> [] && lower_bounds <> [] &&
    List.length l = size
    ==> 
    good_poly_length (extract_poly (List.hd system)) l
    [@@auto]
    [@@disable Certificate.mk_geq_poly]

lemma well_formed_mk_geq_constraints' coeffs upper_bounds lower_bounds i size system l =
    system = mk_geq_constraints' coeffs upper_bounds lower_bounds i size &&
    coeffs <> [] && upper_bounds <> [] && lower_bounds <> [] &&
    List.length l = size
    ==> 
    well_formed system l
    [@@auto]
    [@@disable Certificate.mk_geq_poly]
    [@@fc]

lemma well_formed_mk_geq_constraints coeffs upper_bounds lower_bounds system =
    system = mk_geq_constraints coeffs upper_bounds lower_bounds &&
    coeffs <> [] && upper_bounds <> [] && lower_bounds <> []
    ==>
    well_formed system coeffs
[@@auto]
[@@disable Certificate.mk_geq_poly]
[@@fc]

lemma well_formed_concat s1 s2 x =
    well_formed s1 x &&
    well_formed s2 x 
    ==>
    well_formed (s1 @ s2) x
[@@auto]
[@@fc]



(** Linear combination size invariant *)

lemma well_formed_combination_hd tableau =
    well_formed_tableau tableau
    ==>
    List.length (repeat 0. (List.length (List.hd tableau))) = List.length (List.hd tableau)
[@@auto]
[@@fc]

lemma well_formed_combination_row tableau row =
    well_formed_tableau tableau &&
    List.mem row tableau
    ==>
    List.length (repeat 0. (List.length (List.hd tableau))) = List.length (List.hd tableau)
[@@auto]
[@@apply wf_tableau_eq tableau row]
[@@fc]

lemma well_formed_combination_helper3 lc tableau row =
    well_formed_tableau tableau &&
    List.mem row tableau &&
    List.length lc = List.length (List.hd tableau)
    ==>
    List.length lc = List.length row
[@@auto]
[@@apply wf_tableau_eq tableau row]
[@@fc]


let rec induction_scheme_update_combination (lc: real list) (expl: real list) (tableau: real list list) = 
    match expl, tableau with
    | coeff:: expl', row::tableau' -> induction_scheme_update_combination lc expl' tableau'
    | [], [] -> true
    | [], hd :: tl -> true
    | hd :: tl, [] -> true

lemma list_scale_size_preservation lc coeff row =
    List.length lc = List.length row 
    ==>
    List.length lc  = List.length (Utils.list_scale row coeff)
    [@@auto]
    [@@fc]

lemma list_add_scale_size_preservation_helper lc coeff row =
    List.length lc = List.length (Utils.list_scale row coeff) 
    ==>
    List.length lc  = List.length (Utils.list_add lc (Utils.list_scale row coeff))
    [@@auto]
    [@@apply list_add_length_preservation lc (Utils.list_scale row coeff)]
    [@@fc]

lemma list_add_scale_size_preservation lc coeff row =
    List.length lc = List.length row
    ==>
    List.length lc  = List.length (Utils.list_add lc (Utils.list_scale row coeff))
    [@@auto]
    [@@fc]

lemma update_combination_hd_size_preservation lc expl tableau =
    List.length lc = List.length (List.hd tableau) &&
    expl <> []
    ==>
    List.length (update_combination lc [List.hd expl] [List.hd tableau]) = List.length lc
    [@@auto]
    [@@induct functional induction_scheme_update_combination]
    [@@rw][@@fc]


lemma update_combination_expl_hd_size_preservation lc expl tableau =
    List.length lc = List.length (List.hd tableau) &&
    expl <> []
    ==>
    List.length (update_combination lc [List.hd expl] tableau) = List.length lc
    [@@auto]
    [@@apply update_combination_hd_size_preservation lc expl tableau]
    [@@rw][@@fc]

lemma update_combination_size_preservation_helper lc expl tableau =
    List.length lc = List.length (List.hd tableau) &&
    expl <> []
    ==>
    List.length (update_combination lc expl [List.hd tableau]) = List.length lc
    [@@auto]
    [@@disable List.length]
    [@@rw][@@fc]
