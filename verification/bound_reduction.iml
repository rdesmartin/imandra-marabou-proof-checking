open Farkas_lemma
open Tightening
open Utils
open Certificate
open Arithmetic

lemma is_upper_bounded_tl x u = 
    is_upper_bounded x u
    ==> 
    is_upper_bounded (List.tl x) (List.tl u)
    [@@auto]
    [@@fc]

lemma is_upper_bounded_tl xs ubs x ub = 
    is_upper_bounded xs ubs && x <=. ub
    ==> 
    is_upper_bounded (x::xs) (ub::ubs)
    [@@auto]
    [@@fc]

lemma is_upper_bounded_hd x u = 
    is_upper_bounded x u 
    ==> 
    (List.hd u) -. (List.hd x)  >=. 0.
[@@auto]
[@@fc]

lemma is_upper_bounded_nth x xn u un n =
    List.length x = List.length u &&
    is_upper_bounded x u &&
    Some xn = List.nth n x &&
    Some un = List.nth n u
    ==>   
    -. xn >=. -. un
    [@@auto]

lemma is_upper_bounded_nth_matching xs ubs i = 
    i >=0 && i < List.length xs && List.length xs = List.length ubs &&
    is_upper_bounded xs ubs ==>
    match List.nth i ubs, List.nth i xs with
    | Some ub, Some x -> -. x >=. -. ub
    | _ -> false
[@@auto][@@fc]

(* this lemma depends on mk_bound_poly_eval_gal, defined in verification/mk_bound_poly.iml *)
lemma mk_bound_poly_eval var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var
    ==>
    eval_poly (mk_bound_poly (List.length x) var_i coeff value) x = coeff *. var +. value
    [@@auto]
    [@@apply mk_bound_poly_eval_gal (List.length x) var_i coeff value x var]
    [@@fc]

lemma mk_bound_poly_non_neg var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. value
    ==>
    eval_poly (mk_bound_poly (List.length x) var_i coeff (-. value)) x >=. 0.
    [@@auto]
    [@@apply mk_bound_poly_eval var var_i (-. value) coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

lemma mk_bound_poly_eval_geq_true var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. value
    ==>
    eval_system [Geq (mk_bound_poly (List.length x) var_i coeff (-. value))] x
    [@@auto]
    [@@apply mk_bound_poly_non_neg var var_i value coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]
    [@@fc]

lemma mk_bound_poly_eval_geq_true' var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. (-. value)
    ==>
    eval_system [Geq (mk_bound_poly (List.length x) var_i coeff value)] x
    [@@auto]
    [@@apply mk_bound_poly_non_neg var var_i (-. value) coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]
    [@@fc]

lemma mk_bound_poly_eval_geq_true_conj var1 var1_i value1 coeff1 var2 var2_i value2 coeff2 x = 
    x <> [] && 
    List.nth var1_i x = Some var1 &&
    List.nth var2_i x = Some var2 &&
    coeff1 *. var1 >=. value1 &&
    coeff2 *. var2 >=. value2
    ==>
    eval_system ((Geq (mk_bound_poly (List.length x) var1_i coeff1 (-. value1))) :: [Geq (mk_bound_poly (List.length x) var2_i coeff2 (-. value2))]) x
    [@@auto]
    [@@apply mk_bound_poly_eval_geq_true var1 var1_i value1 coeff1 x,
        mk_bound_poly_eval_geq_true var2 var2_i value2 coeff2 x
    ]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

    
lemma mk_lower_bounds_constraints_eval_hd_helper (bounds: Real.t list) (size: int) (i: int) =
    bounds <> []
    ==>
    mk_lower_bounds_constraints size i bounds =
    Geq (mk_bound_poly size i 1. (-. (List.hd bounds))) :: mk_lower_bounds_constraints size (i + 1) (List.tl bounds)
    [@@auto]
    [@@rw][@@fc]


lemma mk_upper_bounds_constraints'_eval_hd_helper (ubs: Real.t list) (i: int) =
    ubs <> []
    ==>
    mk_upper_bounds_constraints' (List.length ubs) i ubs =
    (Geq (mk_bound_poly (List.length ubs) i (-1.) (List.hd ubs))) :: mk_upper_bounds_constraints' (List.length ubs) (i + 1) (List.tl ubs)
    [@@auto]
    [@@rw][@@fc]


lemma eval_system_hd_tl s xs =
    well_formed s xs &&
    eval_system s xs
    ==>
    eval_exp (List.hd s) xs && eval_system (List.tl s) xs
    [@@auto][@@rw][@@fc]

lemma eval_system_concat_invariant s1 s2 x = 
    eval_system s1 x && eval_system s2 x 
    ==>
    eval_system (s1 @ s2) x
    [@@auto][@@rw][@@fc]

lemma eval_system_exp_concat e s x = 
    eval_exp e x && eval_system s x 
    ==>
    eval_system (e :: s) x
    [@@auto][@@rw][@@fc]

lemma eval_system_mem_exp e s x =
    eval_system s x && List.mem e s
    ==>
    eval_exp e x
    [@@auto][@@fc]

let eval_exp' x e =
    eval_exp e x

lemma eval_system_mem_exp' e s x =
    eval_system s x && List.mem e s
    ==>
    eval_exp' x e 
    [@@auto][@@fc]

lemma eval_system_forall_mem s x =
    List.for_all (eval_exp' x) s
    ==>
    eval_system s x
    [@@auto][@@disable Farkas_lemma.eval_system][@@fc]

lemma mk_upper_bounds_constraints_length size i upper_bounds = 
 List.length upper_bounds = List.length (mk_upper_bounds_constraints' size i upper_bounds) 
    [@@auto][@@fc]

lemma for_all_tl_hd_forall l f = 
    f (List.hd l) && List.for_all f ( List.tl l  )
    ==> 
    List.for_all f l
    [@@auto]

lemma upper_bounded_eval_exp_hd ubs xs = 
    is_upper_bounded xs ubs && xs <> []
    ==>
    eval_exp (List.hd (mk_upper_bounds_constraints' (List.length ubs) 0 ubs)) xs
    [@@auto][@@fc]

lemma upper_bounded_eval_exp ubs xs i ub = 
    List.nth i ubs = Some ub
    && is_upper_bounded xs ubs
    ==>
    eval_exp (Geq (mk_bound_poly (List.length ubs) i (-1.) ub)) xs
    [@@auto][@@apply bounded_is_correct xs ubs i][@@fc]


lemma upper_bounded_eval_exp_matching' ubs xs i = 
    is_upper_bounded xs ubs && i >=0 && i < List.length ubs ==>    
    match List.nth i ubs with 
    | Some ub -> eval_exp (Geq (mk_bound_poly (List.length ubs) i (-1.) ub)) xs
    | None -> false
    [@@auto][@@apply bounded_is_correct xs ubs i][@@fc]

lemma parallel_zero ubs ub = 
    ubs <> [] && List.hd ubs = ub ==>
    List.hd (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) = (Geq (mk_bound_poly (List.length ubs) 0 (-1.) ub))
    [@@auto][@@fc]

lemma parallel_zeroth ubs ub = 
    List.nth 0 ubs = Some ub
    ==>
    List.nth 0 (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) = Some (Geq (mk_bound_poly (List.length ubs) 0 (-1.) ub))
    [@@auto][@@fc]


axiom parallel_nth_generalized ubs i ub size = 
    size >= List.length ubs && List.nth i ubs = Some ub
    ==>
    List.nth i (mk_upper_bounds_constraints size ubs) = Some (Geq (mk_bound_poly size i (-1.) ub))

axiom parallel_nth ubs i ub size = 
    size >= List.length ubs && List.nth i ubs = Some ub
    ==>
    List.nth i (mk_upper_bounds_constraints' size 0 ubs) = Some (Geq (mk_bound_poly size i (-1.) ub))
    [@@auto][@@disable Certificate.mk_bound_poly][@@fc]

lemma parallel_nth_fixed_size ubs i ub = 
    List.nth i ubs = Some ub
    ==>
    List.nth i (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) = Some (Geq (mk_bound_poly (List.length ubs) i (-1.) ub))
    [@@auto][@@fc]
    [@@apply parallel_nth ubs i ub (List.length ubs)]

let rec eval_system_up_to s i xs = 
    if i < 0 || i >= List.length s then true
    else eval_exp (List.hd s) xs &&
        eval_system_up_to (List.tl s) (i-1) xs

lemma eval_system_up_to_forall s xs = 
    eval_system_up_to s (List.length s - 1) xs
    ==>
    eval_system s xs
    [@@auto][@@rw]

lemma eval_up_to_uses_nt s xs i p = 
    List.nth i s = Some p && eval_exp p xs && 
    eval_system_up_to s (i-1) xs 
    ==>
    eval_system_up_to s i xs 
[@@auto][@@fc]

lemma eval_up_to_uses_nt_matching' s xs i = 
    eval_system_up_to s (i-1) xs && i >=0 && i < List.length s ==>
    match List.nth i s with
    | Some p -> eval_exp p xs ==> eval_system_up_to s i xs 
    | None -> false
[@@auto][@@fc]

lemma eval_up_to_uses_nt s xs i e = 
    eval_exp e xs && eval_system_up_to s (i-1) xs 
    ==>
    eval_system_up_to (e::s) i xs 
[@@auto][@@rw]

lemma eval_sys_hd_index_0 s xs = 
    eval_exp (List.hd s) xs
    ==>
    eval_system_up_to s 0 xs 
[@@auto]

 (* uses parallel nth*)
lemma upper_bounds_constraint_nth ubs xs i = 
    is_upper_bounded xs ubs &&
    List.length ubs = List.length xs && i >=0 && i < List.length (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) ==>
    match List.nth i (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) with
    | Some e -> eval_exp e xs
    | None -> false
    [@@auto][@@apply upper_bounded_eval_exp_matching' ubs xs i][@@disable Farkas_lemma.eval_exp][@@fc]

lemma eval_up_tu_inductive_step ubs xs i = 
    is_upper_bounded xs ubs && List.length ubs = List.length xs && i >= 0 && i < List.length (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) &&  eval_system_up_to (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) (i-1) xs ==>
    eval_system_up_to (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) i xs
    [@@auto][@@disable Farkas_lemma.eval_exp][@@apply  eval_up_to_uses_nt_matching'  (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) xs i,  upper_bounds_constraint_nth ubs xs i][@@rw] 


let rec induct_scheme_i ubs xs i =
    if i < 0 then true 
    else  induct_scheme_i ubs xs (i-1)

lemma upper_bounded_evals_up_to_length ubs xs i = 
    is_upper_bounded xs ubs && List.length ubs = List.length xs && i >=0 && i < List.length (mk_upper_bounds_constraints' (List.length ubs) 0 ubs)  
    ==>
    eval_system_up_to (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) i xs
    [@@auto][@@disable Farkas_lemma.eval_exp][@@induct functional induct_scheme_i][@@rw]

lemma mk_upper_bounds_constraints_eval ubs xs = 
is_upper_bounded xs ubs
==> 
eval_system (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) xs
[@@auto][@@disable Farkas_lemma.eval_exp]
[@@apply eval_system_up_to_forall (mk_upper_bounds_constraints' (List.length ubs) 0 ubs) xs]


(* High-level proof goal *)
(* let mk_geq_constraints_reduction_soundness upper_bounds lower_bounds x =
    List.length x = List.length upper_bounds &&
    List.length x = List.length lower_bounds && 
    is_bounded x upper_bounds lower_bounds
    ==>
    eval_system (mk_geq_constraints upper_bounds lower_bounds) x
    [@@auto] *)