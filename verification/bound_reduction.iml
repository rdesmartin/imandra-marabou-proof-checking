open Farkas_lemma
open Tightening
open Utils
open Certificate
open Arithmetic.LinArith

lemma is_upper_bounded_tl x u = 
    is_upper_bounded x u
    ==> 
    is_upper_bounded (List.tl x) (List.tl u)
    [@@auto]
    [@@fc]

lemma is_upper_bounded_hd x u = 
    is_upper_bounded x u 
    ==> 
    (List.hd u) -. (List.hd x)  >=. 0.
[@@auto]
[@@fc]

lemma is_upper_bounded_nth x xn u un n =
    List.length x = List.length u &&
    is_upper_bounded x u &&
    Some xn = List.nth n x &&
    Some un = List.nth n u
    ==>   
    -. xn >=. -. un
    [@@auto]

(* this lemma depends on mk_bound_poly_eval_gal, defined in verification/mk_bound_poly.iml *)
lemma mk_bound_poly_eval var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var
    ==>
    eval_poly (mk_bound_poly (List.length x) var_i coeff value) x = coeff *. var +. value
    [@@auto]
    [@@apply mk_bound_poly_eval_gal (List.length x) var_i coeff value x var]
    [@@fc]

lemma mk_bound_poly_non_neg var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. value
    ==>
    eval_poly (mk_bound_poly (List.length x) var_i coeff (-. value)) x >=. 0.
    [@@auto]
    [@@apply mk_bound_poly_eval var var_i (-. value) coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

lemma mk_bound_poly_eval_geq_true var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. value
    ==>
    eval_system [Geq (mk_bound_poly (List.length x) var_i coeff (-. value))] x
    [@@auto]
    [@@apply mk_bound_poly_non_neg var var_i value coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]
    [@@fc]

lemma mk_bound_poly_eval_geq_true' var var_i value coeff x = 
    x <> [] &&
    List.nth var_i x = Some var &&
    coeff *. var >=. (-. value)
    ==>
    eval_system [Geq (mk_bound_poly (List.length x) var_i coeff value)] x
    [@@auto]
    [@@apply mk_bound_poly_non_neg var var_i (-. value) coeff x]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]
    [@@fc]

lemma mk_bound_poly_eval_geq_true_conj var1 var1_i value1 coeff1 var2 var2_i value2 coeff2 x = 
    x <> [] && 
    List.nth var1_i x = Some var1 &&
    List.nth var2_i x = Some var2 &&
    coeff1 *. var1 >=. value1 &&
    coeff2 *. var2 >=. value2
    ==>
    eval_system ((Geq (mk_bound_poly (List.length x) var1_i coeff1 (-. value1))) :: [Geq (mk_bound_poly (List.length x) var2_i coeff2 (-. value2))]) x
    [@@auto]
    [@@apply mk_bound_poly_eval_geq_true var1 var1_i value1 coeff1 x,
        mk_bound_poly_eval_geq_true var2 var2_i value2 coeff2 x
    ]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

lemma mk_lower_bounds_constraints_eval_hd_helper (bounds: Real.t list) (size: int) (i: int) =
    bounds <> []
    ==>
    mk_lower_bounds_constraints size i bounds =
    Geq (mk_bound_poly size i 1. (-. (List.hd bounds))) :: mk_lower_bounds_constraints size (i + 1) (List.tl bounds)
    [@@auto]
    [@@rw][@@fc]

lemma eval_system_hd_tl s xs =
    well_formed s xs &&
    eval_system s xs
    ==>
    eval_exp (List.hd s) xs && eval_system (List.tl s) xs
    [@@auto]
    [@@fc]

lemma is_upper_bounded_eval_hd (bounds: Real.t list) (xs: Real.t list) (size: int) (i: int) x_i =
    (* We iterate over elements of bounds (and i), but not of x. As a result, we need a way to resaon about x_i wrt bounds *)
    is_upper_bounded bounds xs &&
    xs <> [] &&
    List.nth i xs = Some x_i &&
    bounds <> [] &&
    size = List.length xs
    ==>
    eval_exp (Geq (mk_bound_poly size 0 1. (-. (List.hd bounds)))) xs
    [@@auto]
    [@@apply is_upper_bounded_hd bounds xs,
        mk_bound_poly_non_neg x_i i (-. (List.hd bounds)) 1. xs,
        mk_lower_bounds_constraints_eval_hd_helper bounds size i]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

lemma mk_lower_bounds_constraints_eval_rec bounds xs size i x_i =
    is_upper_bounded bounds xs &&
    xs <> [] &&
    List.nth i xs = Some x_i &&
    bounds <> [] &&
    size = List.length xs &&
    well_formed (mk_lower_bounds_constraints size i bounds) xs &&
    eval_system (mk_lower_bounds_constraints size i bounds) xs
    ==>
    eval_exp (Geq (mk_bound_poly size i 1. (-. (List.hd bounds)))) xs &&
    eval_system (mk_lower_bounds_constraints size (i + 1) (List.tl bounds)) xs
    [@@auto]
    [@@disable Farkas_lemma.eval_system]
    [@@apply eval_system_hd_tl (mk_lower_bounds_constraints size i bounds) xs]

let rec induct_scheme bounds xs i =
    if i >= 0 then induct_scheme bounds xs (i - 1)
    else true

lemma mk_lower_bounds_constraints_eval (bounds: Real.t list) (xs: Real.t list) (i: int) =
    0 <= i && i <= size &&
    is_upper_bounded bounds xs
    ==>
    eval_system (mk_lower_bounds_constraints (List.length bounds) i bounds) xs
    [@@auto]
    [@@induct functional induct_scheme]
    [@@apply LinArith.is_upper_bounded_elem bounds xs ]
    [@@disable Certificate.mk_bound_poly, List.nth, List.length]

(* High-level proof goal *)
lemma mk_geq_constraints_reduction_soundness upper_bounds lower_bounds x =
    List.length x = List.length upper_bounds &&
    List.length x = List.length lower_bounds && 
    is_bounded x upper_bounds lower_bounds
    ==>
    eval_system (mk_geq_constraints upper_bounds lower_bounds) x
    [@@auto]