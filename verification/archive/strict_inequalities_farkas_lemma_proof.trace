# lemma negative_certificate s c =
      has_strict_ineq s = false &&
      check_cert s c 
      ==>
      is_neg_constant (mk_certificate s c)
  [@@rw]
  
  lemma neg_constant (p: poly) (x: var_vect) =
      good_poly_length p x &&
      is_neg_constant p 
      ==> 
      eval_poly p x <. 0.
      [@@auto]
  
  lemma neg_constant_certificate (s: system) (c: Real.t list) (x: var_vect) =
      well_formed s x &&
      is_neg_constant (mk_certificate s c) 
      ==> 
      eval_poly (mk_certificate s c) x <. 0.
      [@@auto]
      [@@apply neg_constant (mk_certificate s c) x]
      [@@disable mk_certificate]
  
  lemma negative_eval_certificate s c x =
      has_strict_ineq s = false &&
      well_formed s x &&
      check_cert s c
      ==>
      eval_poly (mk_certificate s c) x <. 0.
  [@@auto][@@apply neg_constant_certificate s c x][@@fc]
  
  
  (* eval_system s x = true -> eval_poly (mk_certificate s c) x >= 0. *)
  
  lemma non_negative_solution_certificate s c x =
      well_formed s x &&
      has_strict_ineq s = false &&
      s <> [] &&
      eval_system s x 
      ==>
      eval_poly (mk_certificate s c) x >=. 0.
  [@@auto]
  
  lemma non_negative_solution_certificate' s c x = 
      well_formed s x &&
      has_strict_ineq s = false &&
      eval_system s x 
      ==>
      not (eval_poly (mk_certificate s c) x <. 0.)
  [@@auto][@@apply non_negative_solution_certificate s c x]
  
  (* main theorem *)
  theorem farkas_lemma_no_strict_ineq (s: system) (x: var_vect) (c: certificate) =
      well_formed s x &&
      has_strict_ineq s = false &&
      check_cert s c
      ==>
      eval_system s x = false
      [@@auto]
      [@@apply 
      negative_eval_certificate s c x,
      non_negative_solution_certificate' s c x
      ]
  
  (* main theorem *)
  theorem farkas_lemma (s: system) (x: var_vect) (c: certificate) =
      well_formed s x &&
      check_cert s c
      ==>
      eval_system s x = false
      [@@auto]
      [@@apply 
      farkas_lemma_strict_ineq s c x,
      farkas_lemma_no_strict_ineq s c x
      ]
      [@@disable check_cert, well_formed, eval_system];;
val negative_certificate : exp list -> certificate -> bool = <fun>
[✓] Theorem proved.

 ⓘ  Turning theorem negative_certificate into a rewrite rule.
//toplevel//:1,0--141: Warning:
Pattern will match only if `mk_certificate` is disabled
(non-recursive function)
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification

val neg_constant : poly -> var_vect -> bool = <fun>
Goal:

good_poly_length p x && is_neg_constant p ==> eval_poly p x <. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. 0 <= eval_poly p x
 H1. good_poly_length p x
 H2. is_neg_constant p
|---------------------------------------------------------------------------
 false


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from eval_poly.

Induction scheme:

 (not (x <> [] && p <> []) ==> φ p x)
 && (p <> [] && (x <> [] && φ (List.tl p) (List.tl x)) ==> φ p x).

2 nontautological subgoals.

Subgoal 1.2:

 H0. is_neg_constant p
 H1. good_poly_length p x
 H2. 0 <= eval_poly p x
|---------------------------------------------------------------------------
 x <> [] && p <> []

But simplification reduces this to true, using the definitions of eval_poly,
good_poly_length and is_neg_constant.

Subgoal 1.1:

 H0. p <> []
 H1. x <> []
 H2. not (is_neg_constant (List.tl p))
     || not (good_poly_length (List.tl p) (List.tl x))
     || not (0 <= eval_poly (List.tl p) (List.tl x))
 H3. is_neg_constant p
 H4. good_poly_length p x
 H5. 0 <= eval_poly p x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, good_poly_length and
is_neg_constant to the following 2 subgoals:

Subgoal 1.1.2:

 H0. 0 <= List.hd p * List.hd x +. eval_poly (List.tl p) (List.tl x)
 H1. p <> []
 H2. is_neg_constant (List.tl p)
 H3. Is_a([], List.tl p)
 H4. good_poly_length (List.tl p) (List.tl x)
 H5. x <> []
|---------------------------------------------------------------------------
 C0. 0 <= eval_poly (List.tl p) (List.tl x)
 C1. 0 <= List.hd p

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.1.1:

 H0. 0 <= List.hd p * List.hd x +. eval_poly (List.tl p) (List.tl x)
 H1. p <> []
 H2. Is_a([], List.tl p)
 H3. good_poly_length (List.tl p) (List.tl x)
 H4. x <> []
|---------------------------------------------------------------------------
 C0. is_neg_constant (List.tl p)
 C1. 0 <= List.hd p

But simplification reduces this to true, using the definition of
good_poly_length.

 ⓘ  Rules:
    (:def eval_poly)
    (:def good_poly_length)
    (:def is_neg_constant)
    (:fc add_negative)
    (:induct eval_poly)

[✓] Theorem proved.
val neg_constant_certificate : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && is_neg_constant (mk_certificate s c)
==> eval_poly (mk_certificate s c) x <. 0.

A hint has been given, resulting in the following augmented conjecture:

Goal':

(good_poly_length (mk_certificate s c) x
 && is_neg_constant (mk_certificate s c)
 ==> eval_poly (mk_certificate s c) x < 0)
==> well_formed s x && is_neg_constant (mk_certificate s c)
    ==> eval_poly (mk_certificate s c) x < 0.

1 nontautological subgoal.

Subgoal 1:

 H0. 0 <= eval_poly (mk_certificate s c) x
 H1. well_formed s x
 H2. is_neg_constant (mk_certificate s c)
 H3. not (0 <= eval_poly (mk_certificate s c) x)
     || not
        (good_poly_length (mk_certificate s c) x
         && is_neg_constant (mk_certificate s c))
|---------------------------------------------------------------------------
 false

This simplifies, using the forward-chaining rules mk_certificate_good_length
and nonpos_eval_certificate to:

Subgoal 1':

 H0. 0 <= eval_poly (mk_certificate s c) x
 H1. well_formed s x
 H2. is_neg_constant (mk_certificate s c)
|---------------------------------------------------------------------------
 good_poly_length (mk_certificate s c) x


Must try induction.

We shall induct according to a scheme derived from well_formed.

Induction scheme:

 (not (not Is_a([], List.tl s) && (Is_a(Eq, List.hd s) && s <> []))
  && (not
      (not Is_a([], List.tl s)
       && (not Is_a(Geq, List.hd s) && (not Is_a(Eq, List.hd s) && s <> [])))
      && not
         (not Is_a([], List.tl s)
          && (Is_a(Geq, List.hd s) && (not Is_a(Eq, List.hd s) && s <> []))))
  ==> φ c s x)
 && ((s <> []
      && (not Is_a(Eq, List.hd s)
          && (Is_a(Geq, List.hd s)
              && (not Is_a([], List.tl s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (not Is_a(Eq, List.hd s)
              && (not Is_a(Geq, List.hd s)
                  && (not Is_a([], List.tl s) && φ c (List.tl s) x)))
          ==> φ c s x)
         && (s <> []
             && (Is_a(Eq, List.hd s)
                 && (not Is_a([], List.tl s) && φ c (List.tl s) x))
             ==> φ c s x))).

4 nontautological subgoals.

Subgoal 1'.4:

 H0. not (not Is_a([], List.tl s) && Is_a(Eq, List.hd s) && s <> [])
 H1. not
     (not Is_a([], List.tl s) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && s <> [])
 H2. not
     (not Is_a([], List.tl s) && Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && s <> [])
 H3. is_neg_constant (mk_certificate s c)
 H4. 0 <= eval_poly (mk_certificate s c) x
 H5. well_formed s x
|---------------------------------------------------------------------------
 good_poly_length (mk_certificate s c) x

But simplification reduces this to true, using the definition of well_formed,
and the rewrite rule mk_certificate_good_length.

Subgoal 1'.3:

 H0. s <> []
 H1. not Is_a(Eq, List.hd s)
 H2. Is_a(Geq, List.hd s)
 H3. not Is_a([], List.tl s)
 H4. well_formed (List.tl s) x
     && (0 <= eval_poly (mk_certificate (List.tl s) c) x)
     && is_neg_constant (mk_certificate (List.tl s) c)
     ==> good_poly_length (mk_certificate (List.tl s) c) x
 H5. is_neg_constant (mk_certificate s c)
 H6. 0 <= eval_poly (mk_certificate s c) x
 H7. well_formed s x
|---------------------------------------------------------------------------
 good_poly_length (mk_certificate s c) x

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length and nonpos_eval_certificate.

Subgoal 1'.2:

 H0. s <> []
 H1. not Is_a(Eq, List.hd s)
 H2. not Is_a(Geq, List.hd s)
 H3. not Is_a([], List.tl s)
 H4. well_formed (List.tl s) x
     && (0 <= eval_poly (mk_certificate (List.tl s) c) x)
     && is_neg_constant (mk_certificate (List.tl s) c)
     ==> good_poly_length (mk_certificate (List.tl s) c) x
 H5. is_neg_constant (mk_certificate s c)
 H6. 0 <= eval_poly (mk_certificate s c) x
 H7. well_formed s x
|---------------------------------------------------------------------------
 good_poly_length (mk_certificate s c) x

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length and nonpos_eval_certificate.

Subgoal 1'.1:

 H0. is_neg_constant (mk_certificate s c)
 H1. 0 <= eval_poly (mk_certificate s c) x
 H2. well_formed s x
 H3. s <> []
 H4. Is_a(Eq, List.hd s)
 H5. not Is_a([], List.tl s)
 H6. well_formed (List.tl s) x
     && (0 <= eval_poly (mk_certificate (List.tl s) c) x)
     && is_neg_constant (mk_certificate (List.tl s) c)
     ==> good_poly_length (mk_certificate (List.tl s) c) x
|---------------------------------------------------------------------------
 good_poly_length (mk_certificate s c) x

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length and nonpos_eval_certificate.

 ⓘ  Rules:
    (:def well_formed)
    (:rw mk_certificate_good_length)
    (:fc mk_certificate_good_length)
    (:fc nonpos_eval_certificate)
    (:induct well_formed)
    (:app apply_hint.neg_constant_certificate.0)

[✓] Theorem proved.
val negative_eval_certificate : exp list -> certificate -> var_vect -> bool =
  <fun>
Goal:

(has_strict_ineq s = false) && (well_formed s x && check_cert s c)
==> eval_poly (mk_certificate s c) x <. 0.

A hint has been given, resulting in the following augmented conjecture:

Goal':

(well_formed s x && is_neg_constant (sum_polys (scale_system s c))
 ==> eval_poly (sum_polys (scale_system s c)) x < 0)
==> (has_strict_ineq s = false)
    && (well_formed s x
        && (if has_strict_ineq s
            then is_nonpos_constant (sum_polys (scale_system s c))
            else is_neg_constant (sum_polys (scale_system s c))))
    ==> eval_poly (sum_polys (scale_system s c)) x < 0.

1 nontautological subgoal.

Subgoal 1:

 H0. 0 <= eval_poly (sum_polys (scale_system s c)) x
 H1. not (has_strict_ineq s)
 H2. well_formed s x
 H3. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
 H4. not (0 <= eval_poly (sum_polys (scale_system s c)) x)
     || not
        (well_formed s x && is_neg_constant (sum_polys (scale_system s c)))
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

 ⓘ  Rules:
    (:fc scale_system_not_empty)
    (:app apply_hint.negative_eval_certificate.0)

[✓] Theorem proved.

 ⓘ  Turning theorem negative_eval_certificate into a forward-chaining rule.
    Automatic selection of triggers: {eval_poly (mk_certificate s c) x}
//toplevel//:24,0--220: Warning:
Pattern will match only if `mk_certificate` is disabled
(non-recursive function)
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification

val non_negative_solution_certificate :
  system -> real list -> var_vect -> bool = <fun>
Goal:

well_formed s x
&& ((has_strict_ineq s = false) && ((s <> []) && eval_system s x))
==> eval_poly (mk_certificate s c) x >=. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. not (has_strict_ineq s)
 H2. not (s = [])
 H3. eval_system s x
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0


Must try induction.

The recursive terms in the conjecture suggest 4 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s)
   && (not Is_a(Eq, List.hd s) && (not (c <> []) && s <> [])))
  && (not (Is_a(Eq, List.hd s) && (not (c <> []) && s <> []))
      && (not
          ((List.hd c >. 0)
           && (not Is_a(Geq, List.hd s)
               && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
          && (not
              ((List.hd c >=. 0)
               && (Is_a(Geq, List.hd s)
                   && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
              && (not (Is_a(Eq, List.hd s) && (c <> [] && s <> []))
                  && (not
                      (not (List.hd c >. 0)
                       && (not Is_a(Geq, List.hd s)
                           && (not Is_a(Eq, List.hd s)
                               && (c <> [] && s <> []))))
                      && (not
                          (not (List.hd c >=. 0)
                           && (Is_a(Geq, List.hd s)
                               && (not Is_a(Eq, List.hd s)
                                   && (c <> [] && s <> []))))
                          && not
                             (Is_a(Geq, List.hd s)
                              && (not Is_a(Eq, List.hd s)
                                  && (not (c <> []) && s <> [])))))))))
  ==> φ c s x)
 && ((s <> []
      && (not (c <> [])
          && (not Is_a(Eq, List.hd s)
              && (Is_a(Geq, List.hd s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (c <> []
              && (not Is_a(Eq, List.hd s)
                  && (Is_a(Geq, List.hd s)
                      && (not (List.hd c >=. 0)
                          && φ (List.tl c) (List.tl s) x))))
          ==> φ c s x)
         && ((s <> []
              && (c <> []
                  && (not Is_a(Eq, List.hd s)
                      && (not Is_a(Geq, List.hd s)
                          && (not (List.hd c >. 0)
                              && φ (List.tl c) (List.tl s) x))))
              ==> φ c s x)
             && ((s <> []
                  && (c <> []
                      && (Is_a(Eq, List.hd s) && φ (List.tl c) (List.tl s) x))
                  ==> φ c s x)
                 && ((s <> []
                      && (c <> []
                          && (not Is_a(Eq, List.hd s)
                              && (Is_a(Geq, List.hd s)
                                  && ((List.hd c >=. 0)
                                      && φ (List.tl c) (List.tl s) x))))
                      ==> φ c s x)
                     && ((s <> []
                          && (c <> []
                              && (not Is_a(Eq, List.hd s)
                                  && (not Is_a(Geq, List.hd s)
                                      && ((List.hd c >. 0)
                                          && φ (List.tl c) (List.tl s) x))))
                          ==> φ c s x)
                         && ((s <> []
                              && (not (c <> [])
                                  && (Is_a(Eq, List.hd s)
                                      && φ c (List.tl s) x))
                              ==> φ c s x)
                             && (s <> []
                                 && (not (c <> [])
                                     && (not Is_a(Eq, List.hd s)
                                         && (not Is_a(Geq, List.hd s)
                                             && φ c (List.tl s) x)))
                                 ==> φ c s x)))))))).

9 nontautological subgoals.

Subgoal 1.9:

 H0. not
     (not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H1. not (Is_a(Eq, List.hd s) && not (c <> []) && s <> [])
 H2. not
     (not (List.hd c <= 0) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H3. not
     ((List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H4. not (Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H5. not
     ((List.hd c <= 0) && not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H6. not
     (not (List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H7. not
     (Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H8. s <> []
 H9. eval_system s x
 H10. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

Subgoal 1.8:

 H0. s <> []
 H1. eval_system s x
 H2. s <> []
 H3. not (c <> [])
 H4. not Is_a(Eq, List.hd s)
 H5. Is_a(Geq, List.hd s)
 H6. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0)
 H7. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.8.2:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. Is_a(Geq, List.hd s)
 H2. well_formed (List.tl s) x
 H3. eval_system (List.tl s) x
 H4. eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0
 H5. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H6. s <> []
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x >= 0
 C2. has_strict_ineq (List.tl s)
 C3. Is_a([], List.tl s)

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.8.1:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. Is_a([], List.tl s)
 H2. Is_a(Geq, List.hd s)
 H3. eval_system (List.tl s) x
 H4. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H5. s <> []
|---------------------------------------------------------------------------
 C0. c <> []
 C1. has_strict_ineq (List.tl s)
 C2. eval_poly [] x >= 0
 C3. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.7:

 H0. s <> []
 H1. eval_system s x
 H2. s <> []
 H3. c <> []
 H4. not Is_a(Eq, List.hd s)
 H5. Is_a(Geq, List.hd s)
 H6. not (List.hd c >= 0)
 H7. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0)
 H8. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.7.2:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. c <> []
 H2. Is_a(Geq, List.hd s)
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H6. s <> []
 H7. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
|---------------------------------------------------------------------------
 C0. List.hd c >= 0
 C1. has_strict_ineq (List.tl s)
 C2. Is_a([], List.tl s)
 C3. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.7.1:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. Is_a([], List.tl s)
 H2. c <> []
 H3. Is_a(Geq, List.hd s)
 H4. eval_system (List.tl s) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H6. s <> []
|---------------------------------------------------------------------------
 C0. List.hd c >= 0
 C1. Is_a([], scale_system (List.tl s) (List.tl c))
 C2. has_strict_ineq (List.tl s)
 C3. eval_poly [] x >= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. not Is_a(Geq, List.hd s)
 H4. List.hd c <= 0
 H5. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0)
 H6. s <> []
 H7. eval_system s x
 H8. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

Subgoal 1.5:

 H0. s <> []
 H1. c <> []
 H2. Is_a(Eq, List.hd s)
 H3. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0)
 H4. s <> []
 H5. eval_system s x
 H6. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.5.2:

 H0. Is_a(Eq, List.hd s)
 H1. c <> []
 H2. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. s <> []
 H6. good_poly_length (Destruct(Eq, 0, List.hd s)) x
 H7. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s)
 C1. Is_a([], List.tl s)
 C2. eval_poly
     (p_add (p_scale (Destruct(Eq, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.5.1:

 H0. Is_a(Eq, List.hd s)
 H1. Is_a([], List.tl s)
 H2. c <> []
 H3. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H4. eval_system (List.tl s) x
 H5. s <> []
 H6. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s) (List.tl c))
 C1. has_strict_ineq (List.tl s)
 C2. eval_poly [] x >= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.4:

 H0. s <> []
 H1. eval_system s x
 H2. s <> []
 H3. c <> []
 H4. not Is_a(Eq, List.hd s)
 H5. Is_a(Geq, List.hd s)
 H6. List.hd c >= 0
 H7. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0)
 H8. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.4.2:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. c <> []
 H2. List.hd c >= 0
 H3. Is_a(Geq, List.hd s)
 H4. well_formed (List.tl s) x
 H5. eval_system (List.tl s) x
 H6. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H7. s <> []
 H8. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s)
 C1. Is_a([], List.tl s)
 C2. eval_poly
     (p_add (p_scale (Destruct(Geq, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.4.1:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H1. Is_a([], List.tl s)
 H2. c <> []
 H3. List.hd c >= 0
 H4. Is_a(Geq, List.hd s)
 H5. eval_system (List.tl s) x
 H6. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H7. s <> []
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s) (List.tl c))
 C1. has_strict_ineq (List.tl s)
 C2. eval_poly [] x >= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.3:

 H0. s <> []
 H1. eval_system s x
 H2. well_formed s x
 H3. s <> []
 H4. c <> []
 H5. not Is_a(Eq, List.hd s)
 H6. not Is_a(Geq, List.hd s)
 H7. not (List.hd c <= 0)
 H8. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0)
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

Subgoal 1.2:

 H0. s <> []
 H1. eval_system s x
 H2. s <> []
 H3. not (c <> [])
 H4. Is_a(Eq, List.hd s)
 H5. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0)
 H6. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.2.2:

 H0. Is_a(Eq, List.hd s)
 H1. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H2. well_formed (List.tl s) x
 H3. eval_system (List.tl s) x
 H4. eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0
 H5. s <> []
 H6. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. has_strict_ineq (List.tl s)
 C2. Is_a([], List.tl s)
 C3. eval_poly
     (p_add (Destruct(Eq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.2.1:

 H0. Is_a(Eq, List.hd s)
 H1. Is_a([], List.tl s)
 H2. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H3. eval_system (List.tl s) x
 H4. s <> []
 H5. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. has_strict_ineq (List.tl s)
 C2. eval_poly [] x >= 0
 C3. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.1:

 H0. s <> []
 H1. eval_system s x
 H2. s <> []
 H3. not (c <> [])
 H4. not Is_a(Eq, List.hd s)
 H5. not Is_a(Geq, List.hd s)
 H6. has_strict_ineq (List.tl s) || not (well_formed (List.tl s) x)
     || (List.tl s = []) || not (eval_system (List.tl s) x)
     || (eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0)
 H7. well_formed s x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s
 C1. eval_poly (sum_polys (scale_system s c)) x >= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

 ⓘ  Rules:
    (:def eval_poly)
    (:def eval_system)
    (:def has_strict_ineq)
    (:def p_add)
    (:def scale_system)
    (:def sum_polys)
    (:def well_formed)
    (:rw eval_p_add_pull)
    (:rw eval_poly_scale)
    (:rw good_length_p_scale)
    (:rw sum_poly_good_length)
    (:fc add_negative)
    (:fc eval_p_add_pull)
    (:fc eval_poly_scale)
    (:fc scale_system_not_empty)
    (:induct scale_system)

[✓] Theorem proved.
val non_negative_solution_certificate' :
  system -> real list -> var_vect -> bool = <fun>
Goal:

well_formed s x && ((has_strict_ineq s = false) && eval_system s x)
==> not (eval_poly (mk_certificate s c) x <. 0).

A hint has been given, resulting in the following augmented conjecture:

Goal':

(well_formed s x
 && ((has_strict_ineq s = false) && (not (s = []) && eval_system s x))
 ==> eval_poly (sum_polys (scale_system s c)) x >= 0)
==> well_formed s x && ((has_strict_ineq s = false) && eval_system s x)
    ==> not (eval_poly (sum_polys (scale_system s c)) x < 0).

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. not (has_strict_ineq s)
 H2. eval_system s x
 H3. well_formed s x && not (has_strict_ineq s) && not (s = [])
     && eval_system s x ==> eval_poly (sum_polys (scale_system s c)) x >= 0
|---------------------------------------------------------------------------
 0 <= eval_poly (sum_polys (scale_system s c)) x

But simplification reduces this to true, using the definitions of eval_poly,
scale_system and sum_polys.

 ⓘ  Rules:
    (:def eval_poly)
    (:def scale_system)
    (:def sum_polys)
    (:fc scale_system_not_empty)
    (:app apply_hint.non_negative_solution_certificate'.0)

[✓] Theorem proved.
val farkas_lemma_no_strict_ineq : system -> var_vect -> certificate -> bool =
  <fun>
Goal:

well_formed s x && ((has_strict_ineq s = false) && check_cert s c)
==> eval_system s x = false.

A hint has been given, resulting in the following augmented conjecture:

Goal':

((has_strict_ineq s = false)
 && (well_formed s x
     && (if has_strict_ineq s
         then is_nonpos_constant (sum_polys (scale_system s c))
         else is_neg_constant (sum_polys (scale_system s c))))
 ==> eval_poly (sum_polys (scale_system s c)) x < 0)
&& (well_formed s x && ((has_strict_ineq s = false) && eval_system s x)
    ==> not (eval_poly (sum_polys (scale_system s c)) x < 0))
==> well_formed s x
    && ((has_strict_ineq s = false)
        && (if has_strict_ineq s
            then is_nonpos_constant (sum_polys (scale_system s c))
            else is_neg_constant (sum_polys (scale_system s c))))
    ==> eval_system s x = false.

1 nontautological subgoal.

Subgoal 1:

 H0. eval_system s x
 H1. well_formed s x
 H2. not (has_strict_ineq s)
 H3. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
 H4. not (0 <= eval_poly (sum_polys (scale_system s c)) x)
     || not
        (not (has_strict_ineq s) && well_formed s x
         && (if has_strict_ineq s
             then is_nonpos_constant (sum_polys (scale_system s c))
             else is_neg_constant (sum_polys (scale_system s c))))
 H5. well_formed s x && not (has_strict_ineq s) && eval_system s x
     ==> 0 <= eval_poly (sum_polys (scale_system s c)) x
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

 ⓘ  Rules:
    (:fc scale_system_not_empty)
    (:app apply_hint.farkas_lemma_no_strict_ineq.0)
    (:app apply_hint.farkas_lemma_no_strict_ineq.1)

[✓] Theorem proved.
Error:
  Type error (env): Unbound value farkas_lemma_strict_ineq
  Hint: Did you mean farkas_lemma_no_strict_ineq?
# (* main theorem *)
  theorem farkas_lemma_no_strict_ineq (s: system) (x: var_vect) (c: certificate) =
      well_formed s x &&
      has_strict_ineq s = false &&
      check_cert s c
      ==>
      eval_system s x = false
      [@@auto]
      [@@apply 
      negative_eval_certificate s c x,
      non_negative_solution_certificate' s c x
      ]
  ;;
val farkas_lemma_no_strict_ineq : system -> var_vect -> certificate -> bool =
  <fun>
Goal:

well_formed s x && ((has_strict_ineq s = false) && check_cert s c)
==> eval_system s x = false.

A hint has been given, resulting in the following augmented conjecture:

Goal':

((has_strict_ineq s = false)
 && (well_formed s x
     && (if has_strict_ineq s
         then is_nonpos_constant (sum_polys (scale_system s c))
         else is_neg_constant (sum_polys (scale_system s c))))
 ==> eval_poly (sum_polys (scale_system s c)) x < 0)
&& (well_formed s x && ((has_strict_ineq s = false) && eval_system s x)
    ==> not (eval_poly (sum_polys (scale_system s c)) x < 0))
==> well_formed s x
    && ((has_strict_ineq s = false)
        && (if has_strict_ineq s
            then is_nonpos_constant (sum_polys (scale_system s c))
            else is_neg_constant (sum_polys (scale_system s c))))
    ==> eval_system s x = false.

1 nontautological subgoal.

Subgoal 1:

 H0. eval_system s x
 H1. well_formed s x
 H2. not (has_strict_ineq s)
 H3. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
 H4. not (0 <= eval_poly (sum_polys (scale_system s c)) x)
     || not
        (not (has_strict_ineq s) && well_formed s x
         && (if has_strict_ineq s
             then is_nonpos_constant (sum_polys (scale_system s c))
             else is_neg_constant (sum_polys (scale_system s c))))
 H5. well_formed s x && not (has_strict_ineq s) && eval_system s x
     ==> 0 <= eval_poly (sum_polys (scale_system s c)) x
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

 ⓘ  Rules:
    (:fc scale_system_not_empty)
    (:app apply_hint.farkas_lemma_no_strict_ineq.0)
    (:app apply_hint.farkas_lemma_no_strict_ineq.1)

[✓] Theorem proved.
# *)
Line 1, characters 0-2:
Warning 2 [comment-not-end]: this is not the end of a comment.

Error:
  Syntax error: syntax error
  At //toplevel//:1,0--1
  1 | *)
      ^
  
# lemma nonpos_certificate s c =
      has_strict_ineq s &&
      check_cert s c 
      ==>
      is_nonpos_constant (mk_certificate s c)
  [@@auto][@@rw]
  
  lemma eval_nonpos_constant (p: poly) (x: var_vect) =
      good_poly_length p x &&
      is_nonpos_constant p 
      ==> 
      eval_poly p x <=. 0.
      [@@auto]
  
  lemma nonpos_constant_certificate (s: system) (c: Real.t list) (x: var_vect) =
      well_formed s x &&
      is_nonpos_constant (mk_certificate s c) 
      ==> 
      eval_poly (mk_certificate s c) x <=. 0.
      [@@auto]
      [@@apply eval_nonpos_constant (mk_certificate s c) x]
      [@@disable mk_certificate]
  
  lemma nonpos_eval_certificate s c x =
      well_formed s x &&
      has_strict_ineq s &&
      check_cert s c
      ==>
      eval_poly (mk_certificate s c) x <=. 0.
  [@@auto][@@apply nonpos_constant_certificate s c x][@@fc]
  ;;
val nonpos_certificate : exp list -> certificate -> bool = <fun>
Goal:

has_strict_ineq s && check_cert s c
==> is_nonpos_constant (mk_certificate s c).

1 nontautological subgoal.

Subgoal 1:

 H0. has_strict_ineq s
 H1. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
|---------------------------------------------------------------------------
 is_nonpos_constant (sum_polys (scale_system s c))

But simplification reduces this to true.

[✓] Theorem proved.

 ⓘ  Turning theorem nonpos_certificate into a rewrite rule.
//toplevel//:1,0--142: Warning:
Pattern will match only if `mk_certificate` is disabled
(non-recursive function)
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification

val eval_nonpos_constant : poly -> var_vect -> bool = <fun>
Goal:

good_poly_length p x && is_nonpos_constant p ==> eval_poly p x <=. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. good_poly_length p x
 H1. is_nonpos_constant p
|---------------------------------------------------------------------------
 eval_poly p x <= 0


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from good_poly_length.

Induction scheme:

 (not (x <> [] && p <> []) ==> φ p x)
 && (p <> [] && (x <> [] && φ (List.tl p) (List.tl x)) ==> φ p x).

2 nontautological subgoals.

Subgoal 1.2:

 H0. good_poly_length p x
 H1. is_nonpos_constant p
|---------------------------------------------------------------------------
 C0. eval_poly p x <= 0
 C1. x <> [] && p <> []

This simplifies, using the definitions of eval_poly, good_poly_length and
is_nonpos_constant to:

Subgoal 1.2':

 H0. is_nonpos_constant p
 H1. p <> []
 H2. Is_a([], List.tl p)
|---------------------------------------------------------------------------
 C0. List.hd p <= 0
 C1. x <> []

But simplification reduces this to true, using the definition of
is_nonpos_constant.

Subgoal 1.1:

 H0. good_poly_length p x
 H1. is_nonpos_constant p
 H2. p <> []
 H3. x <> []
 H4. good_poly_length (List.tl p) (List.tl x)
     && is_nonpos_constant (List.tl p)
     ==> eval_poly (List.tl p) (List.tl x) <= 0
|---------------------------------------------------------------------------
 eval_poly p x <= 0

This simplifies, using the definitions of eval_poly, good_poly_length and
is_nonpos_constant to the following 2 subgoals:

Subgoal 1.1.2:

 H0. good_poly_length (List.tl p) (List.tl x)
 H1. eval_poly (List.tl p) (List.tl x) <= 0
 H2. p <> []
 H3. x <> []
 H4. List.hd p <= 0
 H5. Is_a([], List.tl p)
 H6. is_nonpos_constant (List.tl p)
|---------------------------------------------------------------------------
 List.hd p * List.hd x +. eval_poly (List.tl p) (List.tl x) <= 0

But simplification reduces this to true, using the definition of
is_nonpos_constant.

Subgoal 1.1.1:

 H0. good_poly_length (List.tl p) (List.tl x)
 H1. p <> []
 H2. x <> []
 H3. List.hd p <= 0
 H4. Is_a([], List.tl p)
|---------------------------------------------------------------------------
 C0. is_nonpos_constant (List.tl p)
 C1. List.hd p * List.hd x +. eval_poly (List.tl p) (List.tl x) <= 0

But simplification reduces this to true, using the definitions of eval_poly
and good_poly_length.

 ⓘ  Rules:
    (:def eval_poly)
    (:def good_poly_length)
    (:def is_nonpos_constant)
    (:fc add_negative)
    (:induct good_poly_length)

[✓] Theorem proved.
val nonpos_constant_certificate : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && is_nonpos_constant (mk_certificate s c)
==> eval_poly (mk_certificate s c) x <=. 0.

A hint has been given, resulting in the following augmented conjecture:

Goal':

(good_poly_length (mk_certificate s c) x
 && is_nonpos_constant (mk_certificate s c)
 ==> eval_poly (mk_certificate s c) x <= 0)
==> well_formed s x && is_nonpos_constant (mk_certificate s c)
    ==> eval_poly (mk_certificate s c) x <= 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. is_nonpos_constant (mk_certificate s c)
 H2. good_poly_length (mk_certificate s c) x
     && is_nonpos_constant (mk_certificate s c)
     ==> eval_poly (mk_certificate s c) x <= 0
|---------------------------------------------------------------------------
 eval_poly (mk_certificate s c) x <= 0

This simplifies, using the forward-chaining rules mk_certificate_good_length,
negative_eval_certificate and nonpos_eval_certificate to:

Subgoal 1':

 H0. well_formed s x
 H1. is_nonpos_constant (mk_certificate s c)
|---------------------------------------------------------------------------
 C0. good_poly_length (mk_certificate s c) x
 C1. eval_poly (mk_certificate s c) x <= 0


Must try induction.

We shall induct according to a scheme derived from well_formed.

Induction scheme:

 (not (not Is_a([], List.tl s) && (Is_a(Eq, List.hd s) && s <> []))
  && (not
      (not Is_a([], List.tl s)
       && (not Is_a(Geq, List.hd s) && (not Is_a(Eq, List.hd s) && s <> [])))
      && not
         (not Is_a([], List.tl s)
          && (Is_a(Geq, List.hd s) && (not Is_a(Eq, List.hd s) && s <> []))))
  ==> φ c s x)
 && ((s <> []
      && (not Is_a(Eq, List.hd s)
          && (Is_a(Geq, List.hd s)
              && (not Is_a([], List.tl s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (not Is_a(Eq, List.hd s)
              && (not Is_a(Geq, List.hd s)
                  && (not Is_a([], List.tl s) && φ c (List.tl s) x)))
          ==> φ c s x)
         && (s <> []
             && (Is_a(Eq, List.hd s)
                 && (not Is_a([], List.tl s) && φ c (List.tl s) x))
             ==> φ c s x))).

4 nontautological subgoals.

Subgoal 1'.4:

 H0. well_formed s x
 H1. is_nonpos_constant (mk_certificate s c)
 H2. not (not Is_a([], List.tl s) && Is_a(Eq, List.hd s) && s <> [])
 H3. not
     (not Is_a([], List.tl s) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && s <> [])
 H4. not
     (not Is_a([], List.tl s) && Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && s <> [])
|---------------------------------------------------------------------------
 C0. good_poly_length (mk_certificate s c) x
 C1. eval_poly (mk_certificate s c) x <= 0

But simplification reduces this to true, using the definition of well_formed,
and the rewrite rule mk_certificate_good_length.

Subgoal 1'.3:

 H0. well_formed s x
 H1. is_nonpos_constant (mk_certificate s c)
 H2. s <> []
 H3. not Is_a(Eq, List.hd s)
 H4. Is_a(Geq, List.hd s)
 H5. not Is_a([], List.tl s)
 H6. not (is_nonpos_constant (mk_certificate (List.tl s) c))
     || (eval_poly (mk_certificate (List.tl s) c) x <= 0)
     || not (well_formed (List.tl s) x)
     || good_poly_length (mk_certificate (List.tl s) c) x
|---------------------------------------------------------------------------
 C0. good_poly_length (mk_certificate s c) x
 C1. eval_poly (mk_certificate s c) x <= 0

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length, negative_eval_certificate and
nonpos_eval_certificate.

Subgoal 1'.2:

 H0. s <> []
 H1. not Is_a(Eq, List.hd s)
 H2. not Is_a(Geq, List.hd s)
 H3. not Is_a([], List.tl s)
 H4. not (is_nonpos_constant (mk_certificate (List.tl s) c))
     || (eval_poly (mk_certificate (List.tl s) c) x <= 0)
     || not (well_formed (List.tl s) x)
     || good_poly_length (mk_certificate (List.tl s) c) x
 H5. well_formed s x
 H6. is_nonpos_constant (mk_certificate s c)
|---------------------------------------------------------------------------
 C0. good_poly_length (mk_certificate s c) x
 C1. eval_poly (mk_certificate s c) x <= 0

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length, negative_eval_certificate and
nonpos_eval_certificate.

Subgoal 1'.1:

 H0. well_formed s x
 H1. is_nonpos_constant (mk_certificate s c)
 H2. s <> []
 H3. Is_a(Eq, List.hd s)
 H4. not Is_a([], List.tl s)
 H5. not (is_nonpos_constant (mk_certificate (List.tl s) c))
     || (eval_poly (mk_certificate (List.tl s) c) x <= 0)
     || not (well_formed (List.tl s) x)
     || good_poly_length (mk_certificate (List.tl s) c) x
|---------------------------------------------------------------------------
 C0. good_poly_length (mk_certificate s c) x
 C1. eval_poly (mk_certificate s c) x <= 0

But simplification reduces this to true, using the forward-chaining rules
mk_certificate_good_length, negative_eval_certificate and
nonpos_eval_certificate.

 ⓘ  Rules:
    (:def well_formed)
    (:rw mk_certificate_good_length)
    (:fc mk_certificate_good_length)
    (:fc negative_eval_certificate)
    (:fc nonpos_eval_certificate)
    (:induct well_formed)
    (:app apply_hint.nonpos_constant_certificate.0)

[✓] Theorem proved.
val nonpos_eval_certificate : system -> certificate -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && (has_strict_ineq s && check_cert s c)
==> eval_poly (mk_certificate s c) x <=. 0.

A hint has been given, resulting in the following augmented conjecture:

Goal':

(well_formed s x && is_nonpos_constant (sum_polys (scale_system s c))
 ==> eval_poly (sum_polys (scale_system s c)) x <= 0)
==> well_formed s x
    && (has_strict_ineq s
        && (if has_strict_ineq s
            then is_nonpos_constant (sum_polys (scale_system s c))
            else is_neg_constant (sum_polys (scale_system s c))))
    ==> eval_poly (sum_polys (scale_system s c)) x <= 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. has_strict_ineq s
 H2. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
 H3. well_formed s x && is_nonpos_constant (sum_polys (scale_system s c))
     ==> eval_poly (sum_polys (scale_system s c)) x <= 0
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x <= 0

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

 ⓘ  Rules:
    (:fc scale_system_not_empty)
    (:app apply_hint.nonpos_eval_certificate.0)

[✓] Theorem proved.

 ⓘ  Turning theorem nonpos_eval_certificate into a forward-chaining rule.
    Automatic selection of triggers: {eval_poly (mk_certificate s c) x}
//toplevel//:24,0--214: Warning:
Pattern will match only if `mk_certificate` is disabled
(non-recursive function)
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification

# lemma positive_solution_certificate s c x =
      well_formed s x 
      && eval_system s x 
      && s <> [] 
      && has_strict_ineq s
      ==>
      eval_poly (mk_certificate s c) x >. 0.
  [@@auto]
  ;;
val positive_solution_certificate : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && (eval_system s x && ((s <> []) && has_strict_ineq s))
==> eval_poly (mk_certificate s c) x >. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. eval_system s x
 H2. not (s = [])
 H3. has_strict_ineq s
 H4. eval_poly (sum_polys (scale_system s c)) x <= 0
|---------------------------------------------------------------------------
 false


Must try induction.

The recursive terms in the conjecture suggest 4 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s)
   && (not Is_a(Eq, List.hd s) && (not (c <> []) && s <> [])))
  && (not (Is_a(Eq, List.hd s) && (not (c <> []) && s <> []))
      && (not
          ((List.hd c >. 0)
           && (not Is_a(Geq, List.hd s)
               && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
          && (not
              ((List.hd c >=. 0)
               && (Is_a(Geq, List.hd s)
                   && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
              && (not (Is_a(Eq, List.hd s) && (c <> [] && s <> []))
                  && (not
                      (not (List.hd c >. 0)
                       && (not Is_a(Geq, List.hd s)
                           && (not Is_a(Eq, List.hd s)
                               && (c <> [] && s <> []))))
                      && (not
                          (not (List.hd c >=. 0)
                           && (Is_a(Geq, List.hd s)
                               && (not Is_a(Eq, List.hd s)
                                   && (c <> [] && s <> []))))
                          && not
                             (Is_a(Geq, List.hd s)
                              && (not Is_a(Eq, List.hd s)
                                  && (not (c <> []) && s <> [])))))))))
  ==> φ c s x)
 && ((s <> []
      && (not (c <> [])
          && (not Is_a(Eq, List.hd s)
              && (Is_a(Geq, List.hd s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (c <> []
              && (not Is_a(Eq, List.hd s)
                  && (Is_a(Geq, List.hd s)
                      && (not (List.hd c >=. 0)
                          && φ (List.tl c) (List.tl s) x))))
          ==> φ c s x)
         && ((s <> []
              && (c <> []
                  && (not Is_a(Eq, List.hd s)
                      && (not Is_a(Geq, List.hd s)
                          && (not (List.hd c >. 0)
                              && φ (List.tl c) (List.tl s) x))))
              ==> φ c s x)
             && ((s <> []
                  && (c <> []
                      && (Is_a(Eq, List.hd s) && φ (List.tl c) (List.tl s) x))
                  ==> φ c s x)
                 && ((s <> []
                      && (c <> []
                          && (not Is_a(Eq, List.hd s)
                              && (Is_a(Geq, List.hd s)
                                  && ((List.hd c >=. 0)
                                      && φ (List.tl c) (List.tl s) x))))
                      ==> φ c s x)
                     && ((s <> []
                          && (c <> []
                              && (not Is_a(Eq, List.hd s)
                                  && (not Is_a(Geq, List.hd s)
                                      && ((List.hd c >. 0)
                                          && φ (List.tl c) (List.tl s) x))))
                          ==> φ c s x)
                         && ((s <> []
                              && (not (c <> [])
                                  && (Is_a(Eq, List.hd s)
                                      && φ c (List.tl s) x))
                              ==> φ c s x)
                             && (s <> []
                                 && (not (c <> [])
                                     && (not Is_a(Eq, List.hd s)
                                         && (not Is_a(Geq, List.hd s)
                                             && φ c (List.tl s) x)))
                                 ==> φ c s x)))))))).

9 nontautological subgoals.

Subgoal 1.9:

 H0. has_strict_ineq s
 H1. eval_poly (sum_polys (scale_system s c)) x <= 0
 H2. well_formed s x
 H3. s <> []
 H4. eval_system s x
 H5. not
     (not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H6. not (Is_a(Eq, List.hd s) && not (c <> []) && s <> [])
 H7. not
     (not (List.hd c <= 0) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H8. not
     ((List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H9. not (Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H10. not
      ((List.hd c <= 0) && not Is_a(Geq, List.hd s)
       && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H11. not
      (not (List.hd c >= 0) && Is_a(Geq, List.hd s)
       && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H12. not
      (Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
       && s <> [])
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

Subgoal 1.8:

 H0. has_strict_ineq s
 H1. eval_poly (sum_polys (scale_system s c)) x <= 0
 H2. well_formed s x
 H3. s <> []
 H4. eval_system s x
 H5. s <> []
 H6. not (c <> [])
 H7. not Is_a(Eq, List.hd s)
 H8. Is_a(Geq, List.hd s)
 H9. (List.tl s = []) || not (well_formed (List.tl s) x)
     || not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || not (eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0)
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.8.3:

 H0. (List.tl s) <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H7. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x <= 0
 H8. s <> []
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.8.2:

 H0. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H1. Is_a(Geq, List.hd s)
 H2. eval_system (List.tl s) x
 H3. has_strict_ineq (List.tl s)
 H4. List.tl s = []
 H5. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H6. s <> []
 H7. eval_poly [] x <= 0
|---------------------------------------------------------------------------
 C0. c <> []
 C1. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definitions of eval_poly
and has_strict_ineq.

Subgoal 1.8.1:

 H0. eval_poly (Destruct(Geq, 0, List.hd s)) x <= 0
 H1. Is_a([], scale_system (List.tl s) c)
 H2. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H3. Is_a(Geq, List.hd s)
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. List.tl s = []
 H7. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H8. s <> []
|---------------------------------------------------------------------------
 c <> []

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.7:

 H0. has_strict_ineq s
 H1. eval_poly (sum_polys (scale_system s c)) x <= 0
 H2. well_formed s x
 H3. s <> []
 H4. eval_system s x
 H5. s <> []
 H6. c <> []
 H7. not Is_a(Eq, List.hd s)
 H8. Is_a(Geq, List.hd s)
 H9. not (List.hd c >= 0)
 H10. (List.tl s = [])
      || not
         (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
      || not (well_formed (List.tl s) x) || not (eval_system (List.tl s) x)
      || not (has_strict_ineq (List.tl s))
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.7.3:

 H0. c <> []
 H1. (List.tl s) <> []
 H2. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H3. Is_a(Geq, List.hd s)
 H4. well_formed (List.tl s) x
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H8. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
 H9. s <> []
|---------------------------------------------------------------------------
 C0. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0
 C1. List.hd c >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.7.2:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. eval_system (List.tl s) x
 H4. has_strict_ineq (List.tl s)
 H5. List.tl s = []
 H6. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H7. s <> []
 H8. eval_poly [] x <= 0
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s) (List.tl c))
 C1. List.hd c >= 0

But simplification reduces this to true, using the definitions of eval_poly
and has_strict_ineq.

Subgoal 1.7.1:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x <= 0
 H2. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H3. Is_a(Geq, List.hd s)
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. List.tl s = []
 H7. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H8. s <> []
 H9. Is_a([], scale_system (List.tl s) (List.tl c))
|---------------------------------------------------------------------------
 List.hd c >= 0

But simplification reduces this to true, using the definitions of
has_strict_ineq and scale_system.

Subgoal 1.6:

 H0. has_strict_ineq s
 H1. eval_poly (sum_polys (scale_system s c)) x <= 0
 H2. well_formed s x
 H3. s <> []
 H4. eval_system s x
 H5. s <> []
 H6. c <> []
 H7. not Is_a(Eq, List.hd s)
 H8. not Is_a(Geq, List.hd s)
 H9. List.hd c <= 0
 H10. (List.tl s = [])
      || not
         (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
      || not (well_formed (List.tl s) x) || not (eval_system (List.tl s) x)
      || not (has_strict_ineq (List.tl s))
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.6.3:

 H0. c <> []
 H1. (List.tl s) <> []
 H2. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H6. List.hd c <= 0
 H7. s <> []
 H8. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C1. Is_a(Eq, List.hd s)
 C2. Is_a(Geq, List.hd s)
 C3. has_strict_ineq (List.tl s)

This simplifies, using the rewrite rules eval_p_add_pull and
sum_poly_good_length to:

Subgoal 1.6.3':

 H0. c <> []
 H1. well_formed (List.tl s) x
 H2. eval_system (List.tl s) x
 H3. (List.tl s) <> []
 H4. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H5. List.hd c <= 0
 H6. s <> []
 H7. eval_poly (Destruct(Gt, 0, List.hd s)) x
     +. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C1. Is_a(Eq, List.hd s)
 C2. Is_a(Geq, List.hd s)
 C3. has_strict_ineq (List.tl s)


We can eliminate destructors by the following
substitution:
 c -> c1 :: c2
 s -> s1 :: s2

This produces the modified subgoal:

Subgoal 1.6.3'':

 H0. eval_system s2 x
 H1. c1 <= 0
 H2. well_formed s2 x
 H3. eval_poly (Destruct(Gt, 0, s1)) x
     +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H4. s2 <> []
 H5. good_poly_length (Destruct(Gt, 0, s1)) x
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, s1)) x <= 0
 C1. has_strict_ineq s2
 C2. Is_a(Geq, s1)
 C3. Is_a(Eq, s1)


We can eliminate destructors by the following substitution:
 s1 -> Gt s11

This produces the modified subgoal:

Subgoal 1.6.3''':

 H0. eval_system s2 x
 H1. good_poly_length s11 x
 H2. c1 <= 0
 H3. well_formed s2 x
 H4. s2 <> []
 H5. eval_poly s11 x +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq s2
 C1. eval_poly s11 x <= 0


Candidates for generalization:

 eval_poly s11 x

This produces the modified subgoal:

Subgoal 1.6.3'''':

 H0. eval_system s2 x
 H1. good_poly_length s11 x
 H2. c1 <= 0
 H3. well_formed s2 x
 H4. s2 <> []
 H5. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq s2
 C1. gen_1 <= 0


Must try induction.

The recursive terms in the conjecture suggest 5 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s2)
   && (not Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> [])))
  && (not (Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> []))
      && (not
          ((List.hd c2 >. 0)
           && (not Is_a(Geq, List.hd s2)
               && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
          && (not
              ((List.hd c2 >=. 0)
               && (Is_a(Geq, List.hd s2)
                   && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
              && (not (Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))
                  && (not
                      (not (List.hd c2 >. 0)
                       && (not Is_a(Geq, List.hd s2)
                           && (not Is_a(Eq, List.hd s2)
                               && (c2 <> [] && s2 <> []))))
                      && (not
                          (not (List.hd c2 >=. 0)
                           && (Is_a(Geq, List.hd s2)
                               && (not Is_a(Eq, List.hd s2)
                                   && (c2 <> [] && s2 <> []))))
                          && not
                             (Is_a(Geq, List.hd s2)
                              && (not Is_a(Eq, List.hd s2)
                                  && (not (c2 <> []) && s2 <> [])))))))))
  ==> φ c1 c2 gen_1 s11 s2 x)
 && ((s2 <> []
      && (not (c2 <> [])
          && (not Is_a(Eq, List.hd s2)
              && (Is_a(Geq, List.hd s2) && φ c1 c2 gen_1 s11 (List.tl s2) x)))
      ==> φ c1 c2 gen_1 s11 s2 x)
     && ((s2 <> []
          && (c2 <> []
              && (not Is_a(Eq, List.hd s2)
                  && (Is_a(Geq, List.hd s2)
                      && (not (List.hd c2 >=. 0)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
          ==> φ c1 c2 gen_1 s11 s2 x)
         && ((s2 <> []
              && (c2 <> []
                  && (not Is_a(Eq, List.hd s2)
                      && (not Is_a(Geq, List.hd s2)
                          && (not (List.hd c2 >. 0)
                              && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
              ==> φ c1 c2 gen_1 s11 s2 x)
             && ((s2 <> []
                  && (c2 <> []
                      && (Is_a(Eq, List.hd s2)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))
                  ==> φ c1 c2 gen_1 s11 s2 x)
                 && ((s2 <> []
                      && (c2 <> []
                          && (not Is_a(Eq, List.hd s2)
                              && (Is_a(Geq, List.hd s2)
                                  && ((List.hd c2 >=. 0)
                                      && φ c1 (List.tl c2) gen_1 s11
                                         (List.tl s2) x))))
                      ==> φ c1 c2 gen_1 s11 s2 x)
                     && ((s2 <> []
                          && (c2 <> []
                              && (not Is_a(Eq, List.hd s2)
                                  && (not Is_a(Geq, List.hd s2)
                                      && ((List.hd c2 >. 0)
                                          && φ c1 (List.tl c2) gen_1 s11
                                             (List.tl s2) x))))
                          ==> φ c1 c2 gen_1 s11 s2 x)
                         && ((s2 <> []
                              && (not (c2 <> [])
                                  && (Is_a(Eq, List.hd s2)
                                      && φ c1 c2 gen_1 s11 (List.tl s2) x))
                              ==> φ c1 c2 gen_1 s11 s2 x)
                             && (s2 <> []
                                 && (not (c2 <> [])
                                     && (not Is_a(Eq, List.hd s2)
                                         && (not Is_a(Geq, List.hd s2)
                                             && φ c1 c2 gen_1 s11
                                                (List.tl s2) x)))
                                 ==> φ c1 c2 gen_1 s11 s2 x)))))))).

9 nontautological subgoals.

Subgoal 1.6.3''''.9:

 H0. good_poly_length s11 x
 H1. s2 <> []
 H2. well_formed s2 x
 H3. c1 <= 0
 H4. not
     (not Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H5. not (Is_a(Eq, List.hd s2) && not (c2 <> []) && s2 <> [])
 H6. not
     (not (List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H7. not
     ((List.hd c2 >= 0) && Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2)
      && c2 <> [] && s2 <> [])
 H8. not (Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H9. not
     ((List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H10. not
      (not (List.hd c2 >= 0) && Is_a(Geq, List.hd s2)
       && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H11. not
      (Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
       && s2 <> [])
 H12. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H13. eval_system s2 x
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. has_strict_ineq s2

But simplification reduces this to true, using the forward-chaining rules
add_negative and scale_system_not_empty.

Subgoal 1.6.3''''.8:

 H0. good_poly_length s11 x
 H1. s2 <> []
 H2. well_formed s2 x
 H3. c1 <= 0
 H4. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H5. s2 <> []
 H6. not (c2 <> [])
 H7. not Is_a(Eq, List.hd s2)
 H8. Is_a(Geq, List.hd s2)
 H9. not (well_formed (List.tl s2) x) || not (eval_system (List.tl s2) x)
     || (gen_1 <= 0) || not (good_poly_length s11 x) || not (c1 <= 0)
     || not
        (gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0)
     || not ((List.tl s2) <> []) || has_strict_ineq (List.tl s2)
 H10. eval_system s2 x
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. has_strict_ineq s2

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.6.3''''.8.3:

 H0. well_formed (List.tl s2) x
 H1. eval_system (List.tl s2) x
 H2. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H3. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H4. good_poly_length s11 x
 H5. s2 <> []
 H6. c1 <= 0
 H7. gen_1 +. eval_poly [] x <= 0
 H8. gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0
 H9. Is_a(Geq, List.hd s2)
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. (List.tl s2) <> []
 C2. c2 <> []
 C3. Is_a([], scale_system (List.tl s2) c2)
 C4. has_strict_ineq (List.tl s2)

But simplification reduces this to true, using the definitions of
has_strict_ineq and scale_system.

Subgoal 1.6.3''''.8.2:

 H0. well_formed (List.tl s2) x
 H1. eval_system (List.tl s2) x
 H2. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H3. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H4. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H5. good_poly_length s11 x
 H6. s2 <> []
 H7. c1 <= 0
 H8. Is_a(Geq, List.hd s2)
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. c2 <> []
 C2. Is_a([], scale_system (List.tl s2) c2)
 C3. has_strict_ineq (List.tl s2)
 C4. gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0


We can eliminate destructors by the following substitution:
 s2 -> s21 :: s22

This produces the modified subgoal:

Subgoal 1.6.3''''.8.2':

 H0. well_formed s22 x
 H1. good_poly_length s11 x
 H2. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, s21)) (sum_polys (scale_system s22 c2))) x
     <= 0
 H3. c1 <= 0
 H4. good_poly_length (Destruct(Geq, 0, s21)) x
 H5. Is_a(Geq, s21)
 H6. eval_poly (Destruct(Geq, 0, s21)) x >= 0
 H7. eval_system s22 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s22
 C1. gen_1 <= 0
 C2. gen_1 +. eval_poly (sum_polys (scale_system s22 c2)) x <= 0
 C3. c2 <> []
 C4. Is_a([], scale_system s22 c2)


We can eliminate destructors by the following substitution:
 s21 -> Geq s211

This produces the modified subgoal:

Subgoal 1.6.3''''.8.2'':

 H0. well_formed s22 x
 H1. eval_poly s211 x >= 0
 H2. good_poly_length s11 x
 H3. c1 <= 0
 H4. eval_system s22 x
 H5. gen_1 +. eval_poly (p_add s211 (sum_polys (scale_system s22 c2))) x <= 0
 H6. good_poly_length s211 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s22
 C1. gen_1 <= 0
 C2. gen_1 +. eval_poly (sum_polys (scale_system s22 c2)) x <= 0
 C3. c2 <> []
 C4. Is_a([], scale_system s22 c2)


Candidates for generalization:

 scale_system s22 c2

This produces the modified subgoal:

Subgoal 1.6.3''''.8.2''':

 H0. well_formed s22 x
 H1. eval_poly s211 x >= 0
 H2. good_poly_length s11 x
 H3. c1 <= 0
 H4. eval_system s22 x
 H5. gen_1 +. eval_poly (p_add s211 (sum_polys gen_1)) x <= 0
 H6. good_poly_length s211 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s22
 C1. gen_1 <= 0
 C2. gen_1 +. eval_poly (sum_polys gen_1) x <= 0
 C3. c2 <> []
 C4. Is_a([], gen_1)


Candidates for generalization:

 sum_polys gen_1

This produces the modified subgoal:

Subgoal 1.6.3''''.8.2'''':

 H0. well_formed s22 x
 H1. eval_poly s211 x >= 0
 H2. good_poly_length s11 x
 H3. c1 <= 0
 H4. eval_system s22 x
 H5. gen_1 +. eval_poly (p_add s211 gen_2) x <= 0
 H6. good_poly_length s211 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s22
 C1. gen_1 <= 0
 C2. gen_1 +. eval_poly gen_2 x <= 0
 C3. c2 <> []
 C4. Is_a([], gen_1)


Must try induction.

The recursive terms in the conjecture suggest 8 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from eval_poly.

Induction scheme:

 (not (x <> [] && (s211 <> [] && (s11 <> [] && gen_2 <> [])))
  ==> φ c1 c2 gen_1 gen_1 gen_2 s11 s211 s22 x)
 && (gen_2 <> []
     && (s11 <> []
         && (s211 <> []
             && (x <> []
                 && φ c1 c2 gen_1 gen_1 (List.tl gen_2) (List.tl s11)
                    (List.tl s211) s22 (List.tl x))))
     ==> φ c1 c2 gen_1 gen_1 gen_2 s11 s211 s22 x).

2 nontautological subgoals.

Subgoal 1.6.3''''.8.2''''.2:

 H0. eval_system s22 x
 H1. good_poly_length s211 x
 H2. c1 <= 0
 H3. gen_1 +. eval_poly (p_add s211 gen_2) x <= 0
 H4. eval_poly s211 x >= 0
 H5. good_poly_length s11 x
 H6. well_formed s22 x
|---------------------------------------------------------------------------
 C0. c2 <> []
 C1. gen_1 +. eval_poly gen_2 x <= 0
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. gen_1 <= 0
 C5. x <> [] && s211 <> [] && s11 <> [] && gen_2 <> []

This simplifies, using the definitions of eval_poly, good_poly_length and
p_add, and the rewrite rule eval_p_add_pull to:

Subgoal 1.6.3''''.8.2''''.2':

 H0. eval_system s22 x
 H1. c1 <= 0
 H2. Is_a([], List.tl s211)
 H3. s211 <> []
 H4. List.hd s211 >= 0
 H5. (p_add s211 gen_2) <> []
 H6. Is_a([], List.tl s11)
 H7. gen_1 +. List.hd (p_add s211 gen_2) <= 0
 H8. s11 <> []
 H9. gen_2 <> []
 H10. well_formed s22 x
 H11. Is_a([], List.tl (p_add s211 gen_2))
|---------------------------------------------------------------------------
 C0. c2 <> []
 C1. x <> []
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. Is_a([], List.tl gen_2)
 C5. gen_1 <= 0

This simplifies, using the definition of p_add to:

Subgoal 1.6.3''''.8.2''''.2'':

 H0. eval_system s22 x
 H1. c1 <= 0
 H2. Is_a([], List.tl s211)
 H3. s211 <> []
 H4. List.hd s211 >= 0
 H5. gen_1 +. List.hd s211 +. List.hd gen_2 <= 0
 H6. Is_a([], List.tl s11)
 H7. Is_a([], p_add (List.tl s211) (List.tl gen_2))
 H8. s11 <> []
 H9. gen_2 <> []
 H10. well_formed s22 x
|---------------------------------------------------------------------------
 C0. c2 <> []
 C1. x <> []
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. Is_a([], List.tl gen_2)
 C5. gen_1 <= 0

This simplifies, using the definition of p_add to:

Subgoal 1.6.3''''.8.2''''.2''':

 H0. eval_system s22 x
 H1. c1 <= 0
 H2. Is_a([], List.tl s211)
 H3. s211 <> []
 H4. List.hd s211 >= 0
 H5. gen_1 +. List.hd s211 +. List.hd gen_2 <= 0
 H6. Is_a([], List.tl s11)
 H7. s11 <> []
 H8. gen_2 <> []
 H9. well_formed s22 x
|---------------------------------------------------------------------------
 C0. c2 <> []
 C1. x <> []
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. Is_a([], List.tl gen_2)
 C5. gen_1 <= 0


We can eliminate destructors by the following
substitution:
 s211 -> s2111 :: s2112
 gen_2 -> gen_21 :: gen_22
 s11 -> s111 :: s112

This produces the modified subgoal:

Subgoal 1.6.3''''.8.2''''.2'''':

 H0. eval_system s22 x
 H1. c1 <= 0
 H2. gen_1 +. s2111 +. gen_21 <= 0
 H3. Is_a([], s112)
 H4. s2111 >= 0
 H5. Is_a([], s2112)
 H6. well_formed s22 x
|---------------------------------------------------------------------------
 C0. c2 <> []
 C1. x <> []
 C2. has_strict_ineq s22
 C3. Is_a([], gen_22)
 C4. Is_a([], gen_1)
 C5. gen_1 <= 0


Note: This refutation is specifically for Subgoal 1.6.3''''.8.2''''.2'''',
which may be more general than the original conjecture.

Checkpoints:

 H0. well_formed s22 x
 H1. eval_poly s211 x >= 0
 H2. good_poly_length s11 x
 H3. c1 <= 0
 H4. eval_system s22 x
 H5. gen_1 +. eval_poly (p_add s211 gen_2) x <= 0
 H6. good_poly_length s211 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq s22
 C1. gen_1 <= 0
 C2. gen_1 +. eval_poly gen_2 x <= 0
 C3. c2 <> []
 C4. Is_a([], gen_1)

 H0. eval_system s2 x
 H1. good_poly_length s11 x
 H2. c1 <= 0
 H3. well_formed s2 x
 H4. s2 <> []
 H5. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq s2
 C1. gen_1 <= 0

 ⓘ  Rules:
    (:def eval_poly)
    (:def eval_system)
    (:def good_poly_length)
    (:def has_strict_ineq)
    (:def p_add)
    (:def scale_system)
    (:def sum_polys)
    (:def well_formed)
    (:rw eval_p_add_pull)
    (:rw sum_poly_good_length)
    (:fc add_negative)
    (:fc eval_p_add_pull)
    (:fc scale_system_not_empty)
    (:induct eval_poly)
    (:induct scale_system)

[?] Unknown.
Error:
  validation failed
----------------------------------------------------------------------------
Context: Proof attempt failed (positive_solution_certificate).
# lemma positive_solution_certificate s c x =
      well_formed s x 
      && eval_system s x 
      && s <> [] 
      && has_strict_ineq s
      ==>
      eval_poly (mk_certificate s c) x >=. 0.
  [@@auto]
  ;;
val positive_solution_certificate : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && (eval_system s x && ((s <> []) && has_strict_ineq s))
==> eval_poly (mk_certificate s c) x >=. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. eval_system s x
 H2. not (s = [])
 H3. has_strict_ineq s
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0


Must try induction.

The recursive terms in the conjecture suggest 4 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s)
   && (not Is_a(Eq, List.hd s) && (not (c <> []) && s <> [])))
  && (not (Is_a(Eq, List.hd s) && (not (c <> []) && s <> []))
      && (not
          ((List.hd c >. 0)
           && (not Is_a(Geq, List.hd s)
               && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
          && (not
              ((List.hd c >=. 0)
               && (Is_a(Geq, List.hd s)
                   && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
              && (not (Is_a(Eq, List.hd s) && (c <> [] && s <> []))
                  && (not
                      (not (List.hd c >. 0)
                       && (not Is_a(Geq, List.hd s)
                           && (not Is_a(Eq, List.hd s)
                               && (c <> [] && s <> []))))
                      && (not
                          (not (List.hd c >=. 0)
                           && (Is_a(Geq, List.hd s)
                               && (not Is_a(Eq, List.hd s)
                                   && (c <> [] && s <> []))))
                          && not
                             (Is_a(Geq, List.hd s)
                              && (not Is_a(Eq, List.hd s)
                                  && (not (c <> []) && s <> [])))))))))
  ==> φ c s x)
 && ((s <> []
      && (not (c <> [])
          && (not Is_a(Eq, List.hd s)
              && (Is_a(Geq, List.hd s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (c <> []
              && (not Is_a(Eq, List.hd s)
                  && (Is_a(Geq, List.hd s)
                      && (not (List.hd c >=. 0)
                          && φ (List.tl c) (List.tl s) x))))
          ==> φ c s x)
         && ((s <> []
              && (c <> []
                  && (not Is_a(Eq, List.hd s)
                      && (not Is_a(Geq, List.hd s)
                          && (not (List.hd c >. 0)
                              && φ (List.tl c) (List.tl s) x))))
              ==> φ c s x)
             && ((s <> []
                  && (c <> []
                      && (Is_a(Eq, List.hd s) && φ (List.tl c) (List.tl s) x))
                  ==> φ c s x)
                 && ((s <> []
                      && (c <> []
                          && (not Is_a(Eq, List.hd s)
                              && (Is_a(Geq, List.hd s)
                                  && ((List.hd c >=. 0)
                                      && φ (List.tl c) (List.tl s) x))))
                      ==> φ c s x)
                     && ((s <> []
                          && (c <> []
                              && (not Is_a(Eq, List.hd s)
                                  && (not Is_a(Geq, List.hd s)
                                      && ((List.hd c >. 0)
                                          && φ (List.tl c) (List.tl s) x))))
                          ==> φ c s x)
                         && ((s <> []
                              && (not (c <> [])
                                  && (Is_a(Eq, List.hd s)
                                      && φ c (List.tl s) x))
                              ==> φ c s x)
                             && (s <> []
                                 && (not (c <> [])
                                     && (not Is_a(Eq, List.hd s)
                                         && (not Is_a(Geq, List.hd s)
                                             && φ c (List.tl s) x)))
                                 ==> φ c s x)))))))).

9 nontautological subgoals.

Subgoal 1.9:

 H0. not
     (not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H1. not (Is_a(Eq, List.hd s) && not (c <> []) && s <> [])
 H2. not
     (not (List.hd c <= 0) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H3. not
     ((List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H4. not (Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H5. not
     ((List.hd c <= 0) && not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H6. not
     (not (List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H7. not
     (Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H8. well_formed s x
 H9. eval_system s x
 H10. s <> []
 H11. has_strict_ineq s
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

Subgoal 1.8:

 H0. s <> []
 H1. not (c <> [])
 H2. not Is_a(Eq, List.hd s)
 H3. Is_a(Geq, List.hd s)
 H4. has_strict_ineq (List.tl s) && well_formed (List.tl s) x
     && eval_system (List.tl s) x && (List.tl s) <> []
     ==> eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0
 H5. well_formed s x
 H6. eval_system s x
 H7. s <> []
 H8. has_strict_ineq s
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.8.2:

 H0. eval_poly (sum_polys (scale_system (List.tl s) c)) x >= 0
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. has_strict_ineq (List.tl s)
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. s <> []
 H6. Is_a(Geq, List.hd s)
 H7. good_poly_length (Destruct(Geq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x >= 0
 C2. Is_a([], List.tl s)

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.8.1:

 H0. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H1. has_strict_ineq (List.tl s)
 H2. eval_system (List.tl s) x
 H3. s <> []
 H4. Is_a(Geq, List.hd s)
 H5. Is_a([], List.tl s)
 H6. good_poly_length (Destruct(Geq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly [] x >= 0
 C2. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.7:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. Is_a(Geq, List.hd s)
 H4. not (List.hd c >= 0)
 H5. has_strict_ineq (List.tl s) && well_formed (List.tl s) x
     && eval_system (List.tl s) x && (List.tl s) <> []
     ==> eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
 H6. well_formed s x
 H7. eval_system s x
 H8. s <> []
 H9. has_strict_ineq s
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.7.2:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. has_strict_ineq (List.tl s)
 H3. well_formed (List.tl s) x
 H4. eval_system (List.tl s) x
 H5. s <> []
 H6. Is_a(Geq, List.hd s)
 H7. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
 H8. good_poly_length (Destruct(Geq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. List.hd c >= 0
 C1. Is_a([], List.tl s)
 C2. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.7.1:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. has_strict_ineq (List.tl s)
 H3. eval_system (List.tl s) x
 H4. s <> []
 H5. Is_a(Geq, List.hd s)
 H6. Is_a([], List.tl s)
 H7. good_poly_length (Destruct(Geq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s) (List.tl c))
 C1. eval_poly [] x >= 0
 C2. List.hd c >= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. not Is_a(Geq, List.hd s)
 H4. List.hd c <= 0
 H5. has_strict_ineq (List.tl s) && well_formed (List.tl s) x
     && eval_system (List.tl s) x && (List.tl s) <> []
     ==> eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
 H6. well_formed s x
 H7. eval_system s x
 H8. s <> []
 H9. has_strict_ineq s
|---------------------------------------------------------------------------
 eval_poly (sum_polys (scale_system s c)) x >= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.6.3:

 H0. c <> []
 H1. has_strict_ineq (List.tl s)
 H2. well_formed (List.tl s) x
 H3. eval_system (List.tl s) x
 H4. s <> []
 H5. List.hd c <= 0
 H6. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0
 H7. good_poly_length (Destruct(Gt, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C1. Is_a(Geq, List.hd s)
 C2. Is_a(Eq, List.hd s)
 C3. Is_a([], List.tl s)
 C4. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2:

 H0. c <> []
 H1. well_formed (List.tl s) x
 H2. eval_system (List.tl s) x
 H3. s <> []
 H4. List.hd c <= 0
 H5. good_poly_length (Destruct(Gt, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C1. has_strict_ineq (List.tl s)
 C2. Is_a(Geq, List.hd s)
 C3. Is_a(Eq, List.hd s)
 C4. Is_a([], List.tl s)
 C5. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x >= 0

This simplifies, using the rewrite rules eval_p_add_pull and
sum_poly_good_length to:

Subgoal 1.6.2':

 H0. c <> []
 H1. well_formed (List.tl s) x
 H2. eval_system (List.tl s) x
 H3. s <> []
 H4. List.hd c <= 0
 H5. good_poly_length (Destruct(Gt, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C1. has_strict_ineq (List.tl s)
 C2. Is_a(Geq, List.hd s)
 C3. Is_a(Eq, List.hd s)
 C4. Is_a([], List.tl s)
 C5. eval_poly (Destruct(Gt, 0, List.hd s)) x
     +. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x >= 0


We can eliminate destructors by the following
substitution:
 c -> c1 :: c2
 s -> s1 :: s2

This produces the modified subgoal:

Subgoal 1.6.2'':

 H0. c1 <= 0
 H1. eval_system s2 x
 H2. well_formed s2 x
 H3. good_poly_length (Destruct(Gt, 0, s1)) x
|---------------------------------------------------------------------------
 C0. eval_poly (Destruct(Gt, 0, s1)) x
     +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C1. eval_poly (Destruct(Gt, 0, s1)) x <= 0
 C2. Is_a(Geq, s1)
 C3. has_strict_ineq s2
 C4. Is_a(Eq, s1)
 C5. Is_a([], s2)


We can eliminate destructors by the following substitution:
 s1 -> Gt s11

This produces the modified subgoal:

Subgoal 1.6.2''':

 H0. c1 <= 0
 H1. good_poly_length s11 x
 H2. eval_system s2 x
 H3. well_formed s2 x
|---------------------------------------------------------------------------
 C0. eval_poly s11 x <= 0
 C1. eval_poly s11 x +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C2. has_strict_ineq s2
 C3. Is_a([], s2)


Candidates for generalization:

 eval_poly s11 x

This produces the modified subgoal:

Subgoal 1.6.2'''':

 H0. c1 <= 0
 H1. good_poly_length s11 x
 H2. eval_system s2 x
 H3. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C2. has_strict_ineq s2
 C3. Is_a([], s2)


Must try induction.

The recursive terms in the conjecture suggest 5 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s2)
   && (not Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> [])))
  && (not (Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> []))
      && (not
          ((List.hd c2 >. 0)
           && (not Is_a(Geq, List.hd s2)
               && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
          && (not
              ((List.hd c2 >=. 0)
               && (Is_a(Geq, List.hd s2)
                   && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
              && (not (Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))
                  && (not
                      (not (List.hd c2 >. 0)
                       && (not Is_a(Geq, List.hd s2)
                           && (not Is_a(Eq, List.hd s2)
                               && (c2 <> [] && s2 <> []))))
                      && (not
                          (not (List.hd c2 >=. 0)
                           && (Is_a(Geq, List.hd s2)
                               && (not Is_a(Eq, List.hd s2)
                                   && (c2 <> [] && s2 <> []))))
                          && not
                             (Is_a(Geq, List.hd s2)
                              && (not Is_a(Eq, List.hd s2)
                                  && (not (c2 <> []) && s2 <> [])))))))))
  ==> φ c1 c2 gen_1 s11 s2 x)
 && ((s2 <> []
      && (not (c2 <> [])
          && (not Is_a(Eq, List.hd s2)
              && (Is_a(Geq, List.hd s2) && φ c1 c2 gen_1 s11 (List.tl s2) x)))
      ==> φ c1 c2 gen_1 s11 s2 x)
     && ((s2 <> []
          && (c2 <> []
              && (not Is_a(Eq, List.hd s2)
                  && (Is_a(Geq, List.hd s2)
                      && (not (List.hd c2 >=. 0)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
          ==> φ c1 c2 gen_1 s11 s2 x)
         && ((s2 <> []
              && (c2 <> []
                  && (not Is_a(Eq, List.hd s2)
                      && (not Is_a(Geq, List.hd s2)
                          && (not (List.hd c2 >. 0)
                              && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
              ==> φ c1 c2 gen_1 s11 s2 x)
             && ((s2 <> []
                  && (c2 <> []
                      && (Is_a(Eq, List.hd s2)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))
                  ==> φ c1 c2 gen_1 s11 s2 x)
                 && ((s2 <> []
                      && (c2 <> []
                          && (not Is_a(Eq, List.hd s2)
                              && (Is_a(Geq, List.hd s2)
                                  && ((List.hd c2 >=. 0)
                                      && φ c1 (List.tl c2) gen_1 s11
                                         (List.tl s2) x))))
                      ==> φ c1 c2 gen_1 s11 s2 x)
                     && ((s2 <> []
                          && (c2 <> []
                              && (not Is_a(Eq, List.hd s2)
                                  && (not Is_a(Geq, List.hd s2)
                                      && ((List.hd c2 >. 0)
                                          && φ c1 (List.tl c2) gen_1 s11
                                             (List.tl s2) x))))
                          ==> φ c1 c2 gen_1 s11 s2 x)
                         && ((s2 <> []
                              && (not (c2 <> [])
                                  && (Is_a(Eq, List.hd s2)
                                      && φ c1 c2 gen_1 s11 (List.tl s2) x))
                              ==> φ c1 c2 gen_1 s11 s2 x)
                             && (s2 <> []
                                 && (not (c2 <> [])
                                     && (not Is_a(Eq, List.hd s2)
                                         && (not Is_a(Geq, List.hd s2)
                                             && φ c1 c2 gen_1 s11
                                                (List.tl s2) x)))
                                 ==> φ c1 c2 gen_1 s11 s2 x)))))))).

9 nontautological subgoals.

Subgoal 1.6.2''''.9:

 H0. well_formed s2 x
 H1. not
     (not Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H2. not (Is_a(Eq, List.hd s2) && not (c2 <> []) && s2 <> [])
 H3. not
     (not (List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H4. not
     ((List.hd c2 >= 0) && Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2)
      && c2 <> [] && s2 <> [])
 H5. not (Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H6. not
     ((List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H7. not
     (not (List.hd c2 >= 0) && Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H8. not
     (Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H9. good_poly_length s11 x
 H10. eval_system s2 x
 H11. c1 <= 0
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C1. has_strict_ineq s2
 C2. Is_a([], s2)
 C3. gen_1 <= 0

But simplification reduces this to true, using the forward-chaining rules
add_negative and scale_system_not_empty.

Subgoal 1.6.2''''.8:

 H0. well_formed s2 x
 H1. good_poly_length s11 x
 H2. eval_system s2 x
 H3. c1 <= 0
 H4. s2 <> []
 H5. not (c2 <> [])
 H6. not Is_a(Eq, List.hd s2)
 H7. Is_a(Geq, List.hd s2)
 H8. (gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x >= 0)
     || has_strict_ineq (List.tl s2) || not (well_formed (List.tl s2) x)
     || Is_a([], List.tl s2) || not (eval_system (List.tl s2) x)
     || not (good_poly_length s11 x) || not (c1 <= 0) || (gen_1 <= 0)
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C1. has_strict_ineq s2
 C2. Is_a([], s2)
 C3. gen_1 <= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, scale_system, sum_polys and well_formed to the following 2
subgoals:

Subgoal 1.6.2''''.8.2:

 H0. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H1. well_formed (List.tl s2) x
 H2. gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x >= 0
 H3. s2 <> []
 H4. eval_system (List.tl s2) x
 H5. good_poly_length s11 x
 H6. Is_a(Geq, List.hd s2)
 H7. c1 <= 0
 H8. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. Is_a([], List.tl s2)
 C2. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     >= 0
 C3. Is_a([], scale_system (List.tl s2) c2)
 C4. gen_1 <= 0
 C5. c2 <> []

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2''''.8.1:

 H0. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H1. s2 <> []
 H2. eval_system (List.tl s2) x
 H3. Is_a([], List.tl s2)
 H4. good_poly_length s11 x
 H5. Is_a(Geq, List.hd s2)
 H6. c1 <= 0
 H7. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     >= 0
 C2. Is_a([], scale_system (List.tl s2) c2)
 C3. gen_1 <= 0
 C4. c2 <> []

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.6.2''''.7:

 H0. well_formed s2 x
 H1. good_poly_length s11 x
 H2. eval_system s2 x
 H3. c1 <= 0
 H4. s2 <> []
 H5. c2 <> []
 H6. not Is_a(Eq, List.hd s2)
 H7. Is_a(Geq, List.hd s2)
 H8. not (List.hd c2 >= 0)
 H9. has_strict_ineq (List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         >= 0)
     || Is_a([], List.tl s2) || not (eval_system (List.tl s2) x)
     || not (good_poly_length s11 x) || not (c1 <= 0) || (gen_1 <= 0)
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C1. has_strict_ineq s2
 C2. Is_a([], s2)
 C3. gen_1 <= 0

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.6.2''''.7.3:

 H0. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. Is_a([], List.tl s2)
 H5. good_poly_length s11 x
 H6. Is_a(Geq, List.hd s2)
 H7. c1 <= 0
 H8. c2 <> []
 H9. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly [] x >= 0
 C1. has_strict_ineq (List.tl s2)
 C2. List.hd c2 >= 0
 C3. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C4. gen_1
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x >= 0
 C5. gen_1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, scale_system and sum_polys.

Subgoal 1.6.2''''.7.2:

 H0. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. good_poly_length s11 x
 H5. Is_a(Geq, List.hd s2)
 H6. c1 <= 0
 H7. c2 <> []
 H8. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H9. gen_1
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x >= 0
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. List.hd c2 >= 0
 C2. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C3. gen_1 <= 0
 C4. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     >= 0


We can eliminate destructors by the following
substitution:
 c2 -> c21 :: c22
 s2 -> s21 :: s22

This produces the modified subgoal:

Subgoal 1.6.2''''.7.2':

 H0. eval_system s22 x
 H1. Is_a(Geq, s21)
 H2. good_poly_length s11 x
 H3. well_formed s22 x
 H4. c1 <= 0
 H5. good_poly_length (Destruct(Geq, 0, s21)) x
 H6. gen_1 +. eval_poly (sum_polys (scale_system s22 c22)) x >= 0
 H7. eval_poly (Destruct(Geq, 0, s21)) x >= 0
|---------------------------------------------------------------------------
 C0. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, s21)) (sum_polys (scale_system s22 c22))) x
     >= 0
 C1. Is_a([], scale_system s22 c22)
 C2. c21 >= 0
 C3. has_strict_ineq s22
 C4. gen_1 <= 0


We can eliminate destructors by the following substitution:
 s21 -> Geq s211

This produces the modified subgoal:

Subgoal 1.6.2''''.7.2'':

 H0. eval_system s22 x
 H1. good_poly_length s211 x
 H2. good_poly_length s11 x
 H3. well_formed s22 x
 H4. c1 <= 0
 H5. gen_1 +. eval_poly (sum_polys (scale_system s22 c22)) x >= 0
 H6. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system s22 c22)
 C1. c21 >= 0
 C2. gen_1 +. eval_poly (p_add s211 (sum_polys (scale_system s22 c22))) x
     >= 0
 C3. has_strict_ineq s22
 C4. gen_1 <= 0


Candidates for generalization:

 scale_system s22 c22

This produces the modified subgoal:

Subgoal 1.6.2''''.7.2''':

 H0. eval_system s22 x
 H1. good_poly_length s211 x
 H2. good_poly_length s11 x
 H3. well_formed s22 x
 H4. c1 <= 0
 H5. gen_1 +. eval_poly (sum_polys gen_1) x >= 0
 H6. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], gen_1)
 C1. c21 >= 0
 C2. gen_1 +. eval_poly (p_add s211 (sum_polys gen_1)) x >= 0
 C3. has_strict_ineq s22
 C4. gen_1 <= 0


Candidates for generalization:

 sum_polys gen_1

This produces the modified subgoal:

Subgoal 1.6.2''''.7.2'''':

 H0. eval_system s22 x
 H1. good_poly_length s211 x
 H2. good_poly_length s11 x
 H3. well_formed s22 x
 H4. c1 <= 0
 H5. gen_1 +. eval_poly gen_2 x >= 0
 H6. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], gen_1)
 C1. c21 >= 0
 C2. gen_1 +. eval_poly (p_add s211 gen_2) x >= 0
 C3. has_strict_ineq s22
 C4. gen_1 <= 0


Must try induction.

The recursive terms in the conjecture suggest 8 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from p_add.

Induction scheme:

 (not (x <> [] && (s211 <> [] && gen_2 <> []))
  ==> φ c1 c21 gen_1 gen_1 gen_2 s11 s211 s22 x)
 && (gen_2 <> []
     && (s211 <> []
         && (x <> []
             && φ c1 c21 gen_1 gen_1 (List.tl gen_2) s11 (List.tl s211) s22
                (List.tl x)))
     ==> φ c1 c21 gen_1 gen_1 gen_2 s11 s211 s22 x).

2 nontautological subgoals.

Subgoal 1.6.2''''.7.2''''.2:

 H0. well_formed s22 x
 H1. c1 <= 0
 H2. gen_1 +. eval_poly gen_2 x >= 0
 H3. good_poly_length s211 x
 H4. good_poly_length s11 x
 H5. eval_system s22 x
 H6. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. c21 >= 0
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. x <> [] && s211 <> [] && gen_2 <> []
 C5. gen_1 +. eval_poly (p_add s211 gen_2) x >= 0

This simplifies, using the definitions of eval_poly and good_poly_length to
the following 4 subgoals:

Subgoal 1.6.2''''.7.2''''.2.4:

 H0. well_formed s22 x
 H1. s11 <> []
 H2. c1 <= 0
 H3. Is_a([], List.tl s11)
 H4. gen_1 >= 0
 H5. Is_a([], List.tl s211)
 H6. eval_system s22 x
 H7. s211 <> []
 H8. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. gen_2 <> []
 C2. c21 >= 0
 C3. has_strict_ineq s22
 C4. Is_a([], gen_1)
 C5. x <> []
 C6. gen_1 +. eval_poly (p_add s211 gen_2) x >= 0

But simplification reduces this to true, using the definitions of eval_poly
and p_add.

Subgoal 1.6.2''''.7.2''''.2.3:

 H0. well_formed s22 x
 H1. s11 <> []
 H2. c1 <= 0
 H3. Is_a([], List.tl s11)
 H4. gen_1 >= 0
 H5. Is_a([], List.tl s211)
 H6. eval_system s22 x
 H7. gen_2 <> []
 H8. s211 <> []
 H9. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. Is_a([], List.tl gen_2)
 C2. c21 >= 0
 C3. has_strict_ineq s22
 C4. Is_a([], gen_1)
 C5. x <> []
 C6. gen_1 +. eval_poly (p_add s211 gen_2) x >= 0

This simplifies, using the definitions of eval_poly and p_add to:

Subgoal 1.6.2''''.7.2''''.2.3':

 H0. List.hd s211 >= 0
 H1. well_formed s22 x
 H2. s11 <> []
 H3. c1 <= 0
 H4. Is_a([], List.tl s11)
 H5. Is_a([], List.tl s211)
 H6. eval_system s22 x
 H7. gen_2 <> []
 H8. s211 <> []
 H9. Is_a([], p_add (List.tl s211) (List.tl gen_2))
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. Is_a([], List.tl gen_2)
 C2. c21 >= 0
 C3. has_strict_ineq s22
 C4. Is_a([], gen_1)
 C5. gen_1 +. List.hd s211 +. List.hd gen_2 >= 0
 C6. x <> []

This simplifies, using the definition of p_add to:

Subgoal 1.6.2''''.7.2''''.2.3'':

 H0. List.hd s211 >= 0
 H1. well_formed s22 x
 H2. s11 <> []
 H3. c1 <= 0
 H4. Is_a([], List.tl s11)
 H5. Is_a([], List.tl s211)
 H6. eval_system s22 x
 H7. gen_2 <> []
 H8. s211 <> []
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. Is_a([], List.tl gen_2)
 C2. c21 >= 0
 C3. has_strict_ineq s22
 C4. Is_a([], gen_1)
 C5. gen_1 +. List.hd s211 +. List.hd gen_2 >= 0
 C6. x <> []


We can eliminate destructors by the following
substitution:
 s211 -> s2111 :: s2112
 gen_2 -> gen_21 :: gen_22
 s11 -> s111 :: s112

This produces the modified subgoal:

Subgoal 1.6.2''''.7.2''''.2.3''':

 H0. Is_a([], s2112)
 H1. well_formed s22 x
 H2. c1 <= 0
 H3. s2111 >= 0
 H4. eval_system s22 x
 H5. Is_a([], s112)
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. c21 >= 0
 C2. has_strict_ineq s22
 C3. Is_a([], gen_1)
 C4. Is_a([], gen_22)
 C5. gen_1 +. s2111 +. gen_21 >= 0
 C6. x <> []


Note: This refutation is specifically for Subgoal 1.6.2''''.7.2''''.2.3''',
which may be more general than the original conjecture.

Checkpoints:

 H0. eval_system s22 x
 H1. good_poly_length s211 x
 H2. good_poly_length s11 x
 H3. well_formed s22 x
 H4. c1 <= 0
 H5. gen_1 +. eval_poly gen_2 x >= 0
 H6. eval_poly s211 x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], gen_1)
 C1. c21 >= 0
 C2. gen_1 +. eval_poly (p_add s211 gen_2) x >= 0
 C3. has_strict_ineq s22
 C4. gen_1 <= 0

 H0. c1 <= 0
 H1. good_poly_length s11 x
 H2. eval_system s2 x
 H3. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_1 <= 0
 C1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x >= 0
 C2. has_strict_ineq s2
 C3. Is_a([], s2)

 ⓘ  Rules:
    (:def eval_poly)
    (:def eval_system)
    (:def good_poly_length)
    (:def has_strict_ineq)
    (:def p_add)
    (:def scale_system)
    (:def sum_polys)
    (:def well_formed)
    (:rw eval_p_add_pull)
    (:rw sum_poly_good_length)
    (:fc add_negative)
    (:fc eval_p_add_pull)
    (:fc scale_system_not_empty)
    (:induct p_add)
    (:induct scale_system)

[?] Unknown.
Error:
  validation failed
----------------------------------------------------------------------------
Context: Proof attempt failed (positive_solution_certificate).
# lemma positive_solution_certificate s c x =
      well_formed s x 
      && eval_system s x 
      && s <> [] 
      && has_strict_ineq s
      ==>
      eval_poly (mk_certificate s c) x >. 0.
  [@@auto]
  
  lemma positive_solution_certificate' s c x = 
      well_formed s x &&
      has_strict_ineq s &&
      eval_system s x 
      ==>
      not (eval_poly (mk_certificate s c) x <=. 0.)
  [@@auto][@@apply positive_solution_certificate s c x]
  
  (* main theorem *)
  theorem farkas_lemma_strict_ineq (s: system) (x: var_vect) (c: certificate) =
      well_formed s x &&
      has_strict_ineq s &&
      check_cert s c
      ==>
      eval_system s x = false
      [@@auto]
      [@@apply 
      nonpos_eval_certificate s c x,
      positive_solution_certificate' s c x
      ]
  ;;
val positive_solution_certificate : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && (eval_system s x && ((s <> []) && has_strict_ineq s))
==> eval_poly (mk_certificate s c) x >. 0.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. eval_system s x
 H2. not (s = [])
 H3. has_strict_ineq s
 H4. eval_poly (sum_polys (scale_system s c)) x <= 0
|---------------------------------------------------------------------------
 false


Must try induction.

The recursive terms in the conjecture suggest 4 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s)
   && (not Is_a(Eq, List.hd s) && (not (c <> []) && s <> [])))
  && (not (Is_a(Eq, List.hd s) && (not (c <> []) && s <> []))
      && (not
          ((List.hd c >. 0)
           && (not Is_a(Geq, List.hd s)
               && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
          && (not
              ((List.hd c >=. 0)
               && (Is_a(Geq, List.hd s)
                   && (not Is_a(Eq, List.hd s) && (c <> [] && s <> []))))
              && (not (Is_a(Eq, List.hd s) && (c <> [] && s <> []))
                  && (not
                      (not (List.hd c >. 0)
                       && (not Is_a(Geq, List.hd s)
                           && (not Is_a(Eq, List.hd s)
                               && (c <> [] && s <> []))))
                      && (not
                          (not (List.hd c >=. 0)
                           && (Is_a(Geq, List.hd s)
                               && (not Is_a(Eq, List.hd s)
                                   && (c <> [] && s <> []))))
                          && not
                             (Is_a(Geq, List.hd s)
                              && (not Is_a(Eq, List.hd s)
                                  && (not (c <> []) && s <> [])))))))))
  ==> φ c s x)
 && ((s <> []
      && (not (c <> [])
          && (not Is_a(Eq, List.hd s)
              && (Is_a(Geq, List.hd s) && φ c (List.tl s) x)))
      ==> φ c s x)
     && ((s <> []
          && (c <> []
              && (not Is_a(Eq, List.hd s)
                  && (Is_a(Geq, List.hd s)
                      && (not (List.hd c >=. 0)
                          && φ (List.tl c) (List.tl s) x))))
          ==> φ c s x)
         && ((s <> []
              && (c <> []
                  && (not Is_a(Eq, List.hd s)
                      && (not Is_a(Geq, List.hd s)
                          && (not (List.hd c >. 0)
                              && φ (List.tl c) (List.tl s) x))))
              ==> φ c s x)
             && ((s <> []
                  && (c <> []
                      && (Is_a(Eq, List.hd s) && φ (List.tl c) (List.tl s) x))
                  ==> φ c s x)
                 && ((s <> []
                      && (c <> []
                          && (not Is_a(Eq, List.hd s)
                              && (Is_a(Geq, List.hd s)
                                  && ((List.hd c >=. 0)
                                      && φ (List.tl c) (List.tl s) x))))
                      ==> φ c s x)
                     && ((s <> []
                          && (c <> []
                              && (not Is_a(Eq, List.hd s)
                                  && (not Is_a(Geq, List.hd s)
                                      && ((List.hd c >. 0)
                                          && φ (List.tl c) (List.tl s) x))))
                          ==> φ c s x)
                         && ((s <> []
                              && (not (c <> [])
                                  && (Is_a(Eq, List.hd s)
                                      && φ c (List.tl s) x))
                              ==> φ c s x)
                             && (s <> []
                                 && (not (c <> [])
                                     && (not Is_a(Eq, List.hd s)
                                         && (not Is_a(Geq, List.hd s)
                                             && φ c (List.tl s) x)))
                                 ==> φ c s x)))))))).

9 nontautological subgoals.

Subgoal 1.9:

 H0. eval_poly (sum_polys (scale_system s c)) x <= 0
 H1. s <> []
 H2. has_strict_ineq s
 H3. not
     (not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
      && s <> [])
 H4. not (Is_a(Eq, List.hd s) && not (c <> []) && s <> [])
 H5. not
     (not (List.hd c <= 0) && not Is_a(Geq, List.hd s)
      && not Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H6. not
     ((List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H7. not (Is_a(Eq, List.hd s) && c <> [] && s <> [])
 H8. not
     ((List.hd c <= 0) && not Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H9. not
     (not (List.hd c >= 0) && Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s)
      && c <> [] && s <> [])
 H10. not
      (Is_a(Geq, List.hd s) && not Is_a(Eq, List.hd s) && not (c <> [])
       && s <> [])
 H11. well_formed s x
 H12. eval_system s x
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

Subgoal 1.8:

 H0. s <> []
 H1. not (c <> [])
 H2. not Is_a(Eq, List.hd s)
 H3. Is_a(Geq, List.hd s)
 H4. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || not (eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0)
     || (List.tl s = []) || not (well_formed (List.tl s) x)
 H5. eval_poly (sum_polys (scale_system s c)) x <= 0
 H6. s <> []
 H7. has_strict_ineq s
 H8. well_formed s x
 H9. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.8.3:

 H0. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x <= 0
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. well_formed (List.tl s) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0
 C2. Is_a([], List.tl s)

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.8.2:

 H0. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H1. Is_a(Geq, List.hd s)
 H2. eval_poly [] x <= 0
 H3. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H4. Is_a([], List.tl s)
 H5. s <> []
 H6. eval_system (List.tl s) x
 H7. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 C0. c <> []
 C1. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.8.1:

 H0. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H1. Is_a(Geq, List.hd s)
 H2. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H3. eval_poly (Destruct(Geq, 0, List.hd s)) x <= 0
 H4. Is_a([], List.tl s)
 H5. Is_a([], scale_system (List.tl s) c)
 H6. s <> []
 H7. eval_system (List.tl s) x
 H8. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 c <> []

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.7:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. Is_a(Geq, List.hd s)
 H4. not (List.hd c >= 0)
 H5. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || (List.tl s = [])
     || not
        (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
     || not (well_formed (List.tl s) x)
 H6. eval_poly (sum_polys (scale_system s c)) x <= 0
 H7. s <> []
 H8. has_strict_ineq s
 H9. well_formed s x
 H10. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.7.3:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. well_formed (List.tl s) x
 H8. eval_poly
     (p_add (Destruct(Geq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
|---------------------------------------------------------------------------
 C0. List.hd c >= 0
 C1. Is_a([], List.tl s)
 C2. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.7.2:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. eval_poly [] x <= 0
 H4. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H5. Is_a([], List.tl s)
 H6. s <> []
 H7. eval_system (List.tl s) x
 H8. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 C0. List.hd c >= 0
 C1. Is_a([], scale_system (List.tl s) (List.tl c))

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.7.1:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a([], scale_system (List.tl s) (List.tl c))
 H3. Is_a(Geq, List.hd s)
 H4. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s)) x <= 0
 H6. Is_a([], List.tl s)
 H7. s <> []
 H8. eval_system (List.tl s) x
 H9. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 List.hd c >= 0

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.6:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. not Is_a(Geq, List.hd s)
 H4. List.hd c <= 0
 H5. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || (List.tl s = [])
     || not
        (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
     || not (well_formed (List.tl s) x)
 H6. eval_poly (sum_polys (scale_system s c)) x <= 0
 H7. s <> []
 H8. has_strict_ineq s
 H9. well_formed s x
 H10. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.6.3:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
 H3. List.hd c <= 0
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. well_formed (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C3. Is_a([], List.tl s)
 C4. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
 H3. List.hd c <= 0
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. well_formed (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C3. has_strict_ineq (List.tl s)
 C4. Is_a([], List.tl s)

This simplifies, using the rewrite rules eval_p_add_pull and
sum_poly_good_length to:

Subgoal 1.6.2':

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. List.hd c <= 0
 H3. s <> []
 H4. eval_system (List.tl s) x
 H5. eval_poly (Destruct(Gt, 0, List.hd s)) x
     +. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0
 H6. well_formed (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C3. has_strict_ineq (List.tl s)
 C4. Is_a([], List.tl s)


We can eliminate destructors by the following
substitution:
 c -> c1 :: c2
 s -> s1 :: s2

This produces the modified subgoal:

Subgoal 1.6.2'':

 H0. good_poly_length (Destruct(Gt, 0, s1)) x
 H1. eval_system s2 x
 H2. c1 <= 0
 H3. eval_poly (Destruct(Gt, 0, s1)) x
     +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H4. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a(Eq, s1)
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. Is_a(Geq, s1)
 C4. eval_poly (Destruct(Gt, 0, s1)) x <= 0


We can eliminate destructors by the following substitution:
 s1 -> Gt s11

This produces the modified subgoal:

Subgoal 1.6.2''':

 H0. eval_system s2 x
 H1. c1 <= 0
 H2. well_formed s2 x
 H3. good_poly_length s11 x
 H4. eval_poly s11 x +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. has_strict_ineq s2
 C2. eval_poly s11 x <= 0


Candidates for generalization:

 eval_poly s11 x

This produces the modified subgoal:

Subgoal 1.6.2'''':

 H0. eval_system s2 x
 H1. c1 <= 0
 H2. well_formed s2 x
 H3. good_poly_length s11 x
 H4. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. has_strict_ineq s2
 C2. gen_1 <= 0


Must try induction.

The recursive terms in the conjecture suggest 5 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s2)
   && (not Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> [])))
  && (not (Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> []))
      && (not
          ((List.hd c2 >. 0)
           && (not Is_a(Geq, List.hd s2)
               && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
          && (not
              ((List.hd c2 >=. 0)
               && (Is_a(Geq, List.hd s2)
                   && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
              && (not (Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))
                  && (not
                      (not (List.hd c2 >. 0)
                       && (not Is_a(Geq, List.hd s2)
                           && (not Is_a(Eq, List.hd s2)
                               && (c2 <> [] && s2 <> []))))
                      && (not
                          (not (List.hd c2 >=. 0)
                           && (Is_a(Geq, List.hd s2)
                               && (not Is_a(Eq, List.hd s2)
                                   && (c2 <> [] && s2 <> []))))
                          && not
                             (Is_a(Geq, List.hd s2)
                              && (not Is_a(Eq, List.hd s2)
                                  && (not (c2 <> []) && s2 <> [])))))))))
  ==> φ c1 c2 gen_1 s11 s2 x)
 && ((s2 <> []
      && (not (c2 <> [])
          && (not Is_a(Eq, List.hd s2)
              && (Is_a(Geq, List.hd s2) && φ c1 c2 gen_1 s11 (List.tl s2) x)))
      ==> φ c1 c2 gen_1 s11 s2 x)
     && ((s2 <> []
          && (c2 <> []
              && (not Is_a(Eq, List.hd s2)
                  && (Is_a(Geq, List.hd s2)
                      && (not (List.hd c2 >=. 0)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
          ==> φ c1 c2 gen_1 s11 s2 x)
         && ((s2 <> []
              && (c2 <> []
                  && (not Is_a(Eq, List.hd s2)
                      && (not Is_a(Geq, List.hd s2)
                          && (not (List.hd c2 >. 0)
                              && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))))
              ==> φ c1 c2 gen_1 s11 s2 x)
             && ((s2 <> []
                  && (c2 <> []
                      && (Is_a(Eq, List.hd s2)
                          && φ c1 (List.tl c2) gen_1 s11 (List.tl s2) x))
                  ==> φ c1 c2 gen_1 s11 s2 x)
                 && ((s2 <> []
                      && (c2 <> []
                          && (not Is_a(Eq, List.hd s2)
                              && (Is_a(Geq, List.hd s2)
                                  && ((List.hd c2 >=. 0)
                                      && φ c1 (List.tl c2) gen_1 s11
                                         (List.tl s2) x))))
                      ==> φ c1 c2 gen_1 s11 s2 x)
                     && ((s2 <> []
                          && (c2 <> []
                              && (not Is_a(Eq, List.hd s2)
                                  && (not Is_a(Geq, List.hd s2)
                                      && ((List.hd c2 >. 0)
                                          && φ c1 (List.tl c2) gen_1 s11
                                             (List.tl s2) x))))
                          ==> φ c1 c2 gen_1 s11 s2 x)
                         && ((s2 <> []
                              && (not (c2 <> [])
                                  && (Is_a(Eq, List.hd s2)
                                      && φ c1 c2 gen_1 s11 (List.tl s2) x))
                              ==> φ c1 c2 gen_1 s11 s2 x)
                             && (s2 <> []
                                 && (not (c2 <> [])
                                     && (not Is_a(Eq, List.hd s2)
                                         && (not Is_a(Geq, List.hd s2)
                                             && φ c1 c2 gen_1 s11
                                                (List.tl s2) x)))
                                 ==> φ c1 c2 gen_1 s11 s2 x)))))))).

9 nontautological subgoals.

Subgoal 1.6.2''''.9:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. c1 <= 0
 H3. good_poly_length s11 x
 H4. well_formed s2 x
 H5. not
     (not Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H6. not (Is_a(Eq, List.hd s2) && not (c2 <> []) && s2 <> [])
 H7. not
     (not (List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H8. not
     ((List.hd c2 >= 0) && Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2)
      && c2 <> [] && s2 <> [])
 H9. not (Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H10. not
      ((List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
       && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H11. not
      (not (List.hd c2 >= 0) && Is_a(Geq, List.hd s2)
       && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H12. not
      (Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
       && s2 <> [])
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

But simplification reduces this to true, using the forward-chaining rules
add_negative and scale_system_not_empty.

Subgoal 1.6.2''''.8:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. s2 <> []
 H3. not (c2 <> [])
 H4. not Is_a(Eq, List.hd s2)
 H5. Is_a(Geq, List.hd s2)
 H6. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0)
     || not
        (gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0)
     || not (c1 <= 0) || not (good_poly_length s11 x)
 H7. c1 <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 2 subgoals:

Subgoal 1.6.2''''.8.2:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H3. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H4. well_formed (List.tl s2) x
 H5. Is_a(Geq, List.hd s2)
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. c1 <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0
 C1. has_strict_ineq (List.tl s2)
 C2. Is_a([], List.tl s2)
 C3. gen_1 <= 0
 C4. c2 <> []

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2''''.8.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a([], List.tl s2)
 H3. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H4. Is_a(Geq, List.hd s2)
 H5. gen_1 +. eval_poly [] x <= 0
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. c1 <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c2)
 C1. has_strict_ineq (List.tl s2)
 C2. gen_1 <= 0
 C3. c2 <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6.2''''.7:

 H0. s2 <> []
 H1. c2 <> []
 H2. not Is_a(Eq, List.hd s2)
 H3. Is_a(Geq, List.hd s2)
 H4. not (List.hd c2 >= 0)
 H5. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || not
        (gen_1
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0) || not (c1 <= 0) || not (good_poly_length s11 x)
 H6. eval_system s2 x
 H7. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H8. c1 <= 0
 H9. good_poly_length s11 x
 H10. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.6.2''''.7.2:

 H0. s2 <> []
 H1. gen_1
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H2. eval_system (List.tl s2) x
 H3. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H4. well_formed (List.tl s2) x
 H5. Is_a(Geq, List.hd s2)
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. c2 <> []
 H8. c1 <= 0
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. List.hd c2 >= 0
 C1. gen_1
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C2. has_strict_ineq (List.tl s2)
 C3. Is_a([], List.tl s2)
 C4. gen_1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2''''.7.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a([], List.tl s2)
 H3. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H4. Is_a(Geq, List.hd s2)
 H5. gen_1 +. eval_poly [] x <= 0
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. c2 <> []
 H8. c1 <= 0
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. List.hd c2 >= 0
 C1. has_strict_ineq (List.tl s2)
 C2. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C3. gen_1 <= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6.2''''.6:

 H0. s2 <> []
 H1. c2 <> []
 H2. not Is_a(Eq, List.hd s2)
 H3. not Is_a(Geq, List.hd s2)
 H4. List.hd c2 <= 0
 H5. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || not
        (gen_1
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0) || not (c1 <= 0) || not (good_poly_length s11 x)
 H6. eval_system s2 x
 H7. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H8. c1 <= 0
 H9. good_poly_length s11 x
 H10. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, has_strict_ineq, scale_system, sum_polys and well_formed.

Subgoal 1.6.2''''.5:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. s2 <> []
 H3. c2 <> []
 H4. Is_a(Eq, List.hd s2)
 H5. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || not
        (gen_1
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0) || not (c1 <= 0) || not (good_poly_length s11 x)
 H6. c1 <= 0
 H7. good_poly_length s11 x
 H8. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.6.2''''.5.2:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H3. gen_1
     +. eval_poly
        (p_add (p_scale (Destruct(Eq, 0, List.hd s2)) (List.hd c2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H4. well_formed (List.tl s2) x
 H5. Is_a(Eq, List.hd s2)
 H6. c2 <> []
 H7. c1 <= 0
 H8. good_poly_length s11 x
 H9. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. gen_1
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C1. has_strict_ineq (List.tl s2)
 C2. Is_a([], List.tl s2)
 C3. gen_1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.6.2''''.5.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a([], List.tl s2)
 H3. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H4. gen_1 +. eval_poly [] x <= 0
 H5. Is_a(Eq, List.hd s2)
 H6. c2 <> []
 H7. c1 <= 0
 H8. good_poly_length s11 x
 H9. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C2. gen_1 <= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6.2''''.4:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. s2 <> []
 H3. c2 <> []
 H4. not Is_a(Eq, List.hd s2)
 H5. Is_a(Geq, List.hd s2)
 H6. List.hd c2 >= 0
 H7. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || not
        (gen_1
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0) || not (c1 <= 0) || not (good_poly_length s11 x)
 H8. c1 <= 0
 H9. good_poly_length s11 x
 H10. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 2 subgoals:

Subgoal 1.6.2''''.4.2:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. List.hd c2 >= 0
 H3. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H4. well_formed (List.tl s2) x
 H5. Is_a(Geq, List.hd s2)
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. c2 <> []
 H8. c1 <= 0
 H9. good_poly_length s11 x
 H10. gen_1
      +. eval_poly
         (p_add (p_scale (Destruct(Geq, 0, List.hd s2)) (List.hd c2))
          (sum_polys (scale_system (List.tl s2) (List.tl c2))))
         x
      <= 0
|---------------------------------------------------------------------------
 C0. gen_1
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C1. has_strict_ineq (List.tl s2)
 C2. Is_a([], List.tl s2)
 C3. gen_1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.6.2''''.4.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a([], List.tl s2)
 H3. List.hd c2 >= 0
 H4. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H5. Is_a(Geq, List.hd s2)
 H6. gen_1 +. eval_poly [] x <= 0
 H7. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H8. c2 <> []
 H9. c1 <= 0
 H10. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C2. gen_1 <= 0

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6.2''''.3:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. c1 <= 0
 H3. good_poly_length s11 x
 H4. well_formed s2 x
 H5. s2 <> []
 H6. c2 <> []
 H7. not Is_a(Eq, List.hd s2)
 H8. not Is_a(Geq, List.hd s2)
 H9. not (List.hd c2 <= 0)
 H10. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
      || not
         (gen_1
          +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
          <= 0)
      || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
      || (gen_1 <= 0) || not (c1 <= 0) || not (good_poly_length s11 x)
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, has_strict_ineq, scale_system, sum_polys and well_formed.

Subgoal 1.6.2''''.2:

 H0. s2 <> []
 H1. not (c2 <> [])
 H2. Is_a(Eq, List.hd s2)
 H3. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0)
     || not
        (gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0)
     || not (c1 <= 0) || not (good_poly_length s11 x)
 H4. eval_system s2 x
 H5. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H6. c1 <= 0
 H7. good_poly_length s11 x
 H8. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 2 subgoals:

Subgoal 1.6.2''''.2.2:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H3. well_formed (List.tl s2) x
 H4. Is_a(Eq, List.hd s2)
 H5. c1 <= 0
 H6. good_poly_length s11 x
 H7. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H8. gen_1
     +. eval_poly
        (p_add (Destruct(Eq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
|---------------------------------------------------------------------------
 C0. gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0
 C1. has_strict_ineq (List.tl s2)
 C2. Is_a([], List.tl s2)
 C3. gen_1 <= 0
 C4. c2 <> []

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.6.2''''.2.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a([], List.tl s2)
 H3. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H4. gen_1 +. eval_poly [] x <= 0
 H5. Is_a(Eq, List.hd s2)
 H6. c1 <= 0
 H7. good_poly_length s11 x
 H8. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c2)
 C1. has_strict_ineq (List.tl s2)
 C2. gen_1 <= 0
 C3. c2 <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.6.2''''.1:

 H0. eval_system s2 x
 H1. gen_1 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. s2 <> []
 H3. not (c2 <> [])
 H4. not Is_a(Eq, List.hd s2)
 H5. not Is_a(Geq, List.hd s2)
 H6. not (eval_system (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || Is_a([], List.tl s2) || not (well_formed (List.tl s2) x)
     || (gen_1 <= 0)
     || not
        (gen_1 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x <= 0)
     || not (c1 <= 0) || not (good_poly_length s11 x)
 H7. c1 <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. gen_1 <= 0
 C2. has_strict_ineq s2

But simplification reduces this to true, using the definitions of
has_strict_ineq and well_formed.

Subgoal 1.6.1:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. eval_poly [] x <= 0
 H3. Is_a([], List.tl s)
 H4. List.hd c <= 0
 H5. s <> []
 H6. eval_system (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C3. Is_a([], scale_system (List.tl s) (List.tl c))

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.5:

 H0. s <> []
 H1. c <> []
 H2. Is_a(Eq, List.hd s)
 H3. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || (List.tl s = [])
     || not
        (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
     || not (well_formed (List.tl s) x)
 H4. eval_poly (sum_polys (scale_system s c)) x <= 0
 H5. s <> []
 H6. has_strict_ineq s
 H7. well_formed s x
 H8. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.5.3:

 H0. c <> []
 H1. Is_a(Eq, List.hd s)
 H2. eval_poly
     (p_add (p_scale (Destruct(Eq, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
 H3. s <> []
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. well_formed (List.tl s) x
 H7. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H8. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. Is_a([], List.tl s)
 C1. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.5.2:

 H0. c <> []
 H1. Is_a(Eq, List.hd s)
 H2. eval_poly [] x <= 0
 H3. Is_a([], List.tl s)
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H8. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 Is_a([], scale_system (List.tl s) (List.tl c))

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.5.1:

 H0. c <> []
 H1. Is_a([], scale_system (List.tl s) (List.tl c))
 H2. Is_a(Eq, List.hd s)
 H3. Is_a([], List.tl s)
 H4. s <> []
 H5. eval_system (List.tl s) x
 H6. has_strict_ineq (List.tl s)
 H7. eval_poly (p_scale (Destruct(Eq, 0, List.hd s)) (List.hd c)) x <= 0
 H8. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H9. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definition of
has_strict_ineq, and the rewrite rule eval_poly_scale.

Subgoal 1.4:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. Is_a(Geq, List.hd s)
 H4. List.hd c >= 0
 H5. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || (List.tl s = [])
     || not
        (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
     || not (well_formed (List.tl s) x)
 H6. eval_poly (sum_polys (scale_system s c)) x <= 0
 H7. s <> []
 H8. has_strict_ineq s
 H9. well_formed s x
 H10. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.4.3:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. List.hd c >= 0
 H4. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H5. s <> []
 H6. eval_system (List.tl s) x
 H7. has_strict_ineq (List.tl s)
 H8. well_formed (List.tl s) x
 H9. eval_poly
     (p_add (p_scale (Destruct(Geq, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
|---------------------------------------------------------------------------
 C0. Is_a([], List.tl s)
 C1. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.4.2:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a(Geq, List.hd s)
 H3. List.hd c >= 0
 H4. eval_poly [] x <= 0
 H5. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H6. Is_a([], List.tl s)
 H7. s <> []
 H8. eval_system (List.tl s) x
 H9. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 Is_a([], scale_system (List.tl s) (List.tl c))

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.4.1:

 H0. c <> []
 H1. eval_poly (Destruct(Geq, 0, List.hd s)) x >= 0
 H2. Is_a([], scale_system (List.tl s) (List.tl c))
 H3. Is_a(Geq, List.hd s)
 H4. List.hd c >= 0
 H5. eval_poly (p_scale (Destruct(Geq, 0, List.hd s)) (List.hd c)) x <= 0
 H6. good_poly_length (Destruct(Geq, 0, List.hd s)) x
 H7. Is_a([], List.tl s)
 H8. s <> []
 H9. eval_system (List.tl s) x
 H10. has_strict_ineq (List.tl s)
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.3:

 H0. s <> []
 H1. c <> []
 H2. not Is_a(Eq, List.hd s)
 H3. not Is_a(Geq, List.hd s)
 H4. not (List.hd c <= 0)
 H5. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || (List.tl s = [])
     || not
        (eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0)
     || not (well_formed (List.tl s) x)
 H6. eval_poly (sum_polys (scale_system s c)) x <= 0
 H7. s <> []
 H8. has_strict_ineq s
 H9. well_formed s x
 H10. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.3.3:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. s <> []
 H3. eval_system (List.tl s) x
 H4. has_strict_ineq (List.tl s)
 H5. well_formed (List.tl s) x
 H6. eval_poly
     (p_add (p_scale (Destruct(Gt, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. List.hd c <= 0
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. Is_a([], List.tl s)
 C5. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.3.2:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. s <> []
 H3. eval_system (List.tl s) x
 H4. well_formed (List.tl s) x
 H5. eval_poly
     (p_add (p_scale (Destruct(Gt, 0, List.hd s)) (List.hd c))
      (sum_polys (scale_system (List.tl s) (List.tl c))))
     x <= 0
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. List.hd c <= 0
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. has_strict_ineq (List.tl s)
 C5. Is_a([], List.tl s)

This simplifies, using the rewrite rules eval_p_add_pull, eval_poly_scale,
good_length_p_scale and sum_poly_good_length to:

Subgoal 1.3.2':

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. List.hd c * eval_poly (Destruct(Gt, 0, List.hd s)) x
     +. eval_poly (sum_polys (scale_system (List.tl s) (List.tl c))) x <= 0
 H3. s <> []
 H4. eval_system (List.tl s) x
 H5. well_formed (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. List.hd c <= 0
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. has_strict_ineq (List.tl s)
 C5. Is_a([], List.tl s)


We can eliminate destructors by the following
substitution:
 c -> c1 :: c2
 s -> s1 :: s2

This produces the modified subgoal:

Subgoal 1.3.2'':

 H0. good_poly_length (Destruct(Gt, 0, s1)) x
 H1. c1 * eval_poly (Destruct(Gt, 0, s1)) x
     +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. well_formed s2 x
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. Is_a(Geq, s1)
 C2. has_strict_ineq s2
 C3. c1 <= 0
 C4. Is_a(Eq, s1)
 C5. eval_poly (Destruct(Gt, 0, s1)) x <= 0


We can eliminate destructors by the following substitution:
 s1 -> Gt s11

This produces the modified subgoal:

Subgoal 1.3.2''':

 H0. good_poly_length s11 x
 H1. c1 * eval_poly s11 x +. eval_poly (sum_polys (scale_system s2 c2)) x
     <= 0
 H2. well_formed s2 x
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. has_strict_ineq s2
 C2. c1 <= 0
 C3. eval_poly s11 x <= 0


Candidates for generalization:

 eval_poly s11 x

This produces the modified subgoal:

Subgoal 1.3.2'''':

 H0. good_poly_length s11 x
 H1. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H2. well_formed s2 x
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. has_strict_ineq s2
 C2. c1 <= 0
 C3. gen_2 <= 0


Must try induction.

The recursive terms in the conjecture suggest 5 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s2)
   && (not Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> [])))
  && (not (Is_a(Eq, List.hd s2) && (not (c2 <> []) && s2 <> []))
      && (not
          ((List.hd c2 >. 0)
           && (not Is_a(Geq, List.hd s2)
               && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
          && (not
              ((List.hd c2 >=. 0)
               && (Is_a(Geq, List.hd s2)
                   && (not Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))))
              && (not (Is_a(Eq, List.hd s2) && (c2 <> [] && s2 <> []))
                  && (not
                      (not (List.hd c2 >. 0)
                       && (not Is_a(Geq, List.hd s2)
                           && (not Is_a(Eq, List.hd s2)
                               && (c2 <> [] && s2 <> []))))
                      && (not
                          (not (List.hd c2 >=. 0)
                           && (Is_a(Geq, List.hd s2)
                               && (not Is_a(Eq, List.hd s2)
                                   && (c2 <> [] && s2 <> []))))
                          && not
                             (Is_a(Geq, List.hd s2)
                              && (not Is_a(Eq, List.hd s2)
                                  && (not (c2 <> []) && s2 <> [])))))))))
  ==> φ c1 c2 gen_2 s11 s2 x)
 && ((s2 <> []
      && (not (c2 <> [])
          && (not Is_a(Eq, List.hd s2)
              && (Is_a(Geq, List.hd s2) && φ c1 c2 gen_2 s11 (List.tl s2) x)))
      ==> φ c1 c2 gen_2 s11 s2 x)
     && ((s2 <> []
          && (c2 <> []
              && (not Is_a(Eq, List.hd s2)
                  && (Is_a(Geq, List.hd s2)
                      && (not (List.hd c2 >=. 0)
                          && φ c1 (List.tl c2) gen_2 s11 (List.tl s2) x))))
          ==> φ c1 c2 gen_2 s11 s2 x)
         && ((s2 <> []
              && (c2 <> []
                  && (not Is_a(Eq, List.hd s2)
                      && (not Is_a(Geq, List.hd s2)
                          && (not (List.hd c2 >. 0)
                              && φ c1 (List.tl c2) gen_2 s11 (List.tl s2) x))))
              ==> φ c1 c2 gen_2 s11 s2 x)
             && ((s2 <> []
                  && (c2 <> []
                      && (Is_a(Eq, List.hd s2)
                          && φ c1 (List.tl c2) gen_2 s11 (List.tl s2) x))
                  ==> φ c1 c2 gen_2 s11 s2 x)
                 && ((s2 <> []
                      && (c2 <> []
                          && (not Is_a(Eq, List.hd s2)
                              && (Is_a(Geq, List.hd s2)
                                  && ((List.hd c2 >=. 0)
                                      && φ c1 (List.tl c2) gen_2 s11
                                         (List.tl s2) x))))
                      ==> φ c1 c2 gen_2 s11 s2 x)
                     && ((s2 <> []
                          && (c2 <> []
                              && (not Is_a(Eq, List.hd s2)
                                  && (not Is_a(Geq, List.hd s2)
                                      && ((List.hd c2 >. 0)
                                          && φ c1 (List.tl c2) gen_2 s11
                                             (List.tl s2) x))))
                          ==> φ c1 c2 gen_2 s11 s2 x)
                         && ((s2 <> []
                              && (not (c2 <> [])
                                  && (Is_a(Eq, List.hd s2)
                                      && φ c1 c2 gen_2 s11 (List.tl s2) x))
                              ==> φ c1 c2 gen_2 s11 s2 x)
                             && (s2 <> []
                                 && (not (c2 <> [])
                                     && (not Is_a(Eq, List.hd s2)
                                         && (not Is_a(Geq, List.hd s2)
                                             && φ c1 c2 gen_2 s11
                                                (List.tl s2) x)))
                                 ==> φ c1 c2 gen_2 s11 s2 x)))))))).

9 nontautological subgoals.

Subgoal 1.3.2''''.9:

 H0. not
     (not Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H1. not (Is_a(Eq, List.hd s2) && not (c2 <> []) && s2 <> [])
 H2. not
     (not (List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H3. not
     ((List.hd c2 >= 0) && Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2)
      && c2 <> [] && s2 <> [])
 H4. not (Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H5. not
     ((List.hd c2 <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H6. not
     (not (List.hd c2 >= 0) && Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c2 <> [] && s2 <> [])
 H7. not
     (Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c2 <> [])
      && s2 <> [])
 H8. well_formed s2 x
 H9. eval_system s2 x
 H10. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H11. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

But simplification reduces this to true, using the forward-chaining rules
add_negative and scale_system_not_empty.

Subgoal 1.3.2''''.8:

 H0. s2 <> []
 H1. not (c2 <> [])
 H2. not Is_a(Eq, List.hd s2)
 H3. Is_a(Geq, List.hd s2)
 H4. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H5. well_formed s2 x
 H6. eval_system s2 x
 H7. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, scale_system, sum_polys and well_formed to the following 2
subgoals:

Subgoal 1.3.2''''.8.2:

 H0. Is_a(Geq, List.hd s2)
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H6. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. c2 <> []
 C2. c1 * gen_2 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x
     <= 0
 C3. gen_2 <= 0
 C4. Is_a([], scale_system (List.tl s2) c2)
 C5. Is_a([], List.tl s2)
 C6. c1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.3.2''''.8.1:

 H0. Is_a(Geq, List.hd s2)
 H1. s2 <> []
 H2. eval_system (List.tl s2) x
 H3. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H4. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H5. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H6. Is_a([], List.tl s2)
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. c2 <> []
 C2. gen_2 <= 0
 C3. Is_a([], scale_system (List.tl s2) c2)
 C4. c1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
p_add, scale_system and sum_polys.

Subgoal 1.3.2''''.7:

 H0. s2 <> []
 H1. c2 <> []
 H2. not Is_a(Eq, List.hd s2)
 H3. Is_a(Geq, List.hd s2)
 H4. not (List.hd c2 >= 0)
 H5. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H6. well_formed s2 x
 H7. eval_system s2 x
 H8. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.3.2''''.7.3:

 H0. Is_a(Geq, List.hd s2)
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H6. c2 <> []
 H7. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. List.hd c2 >= 0
 C2. gen_2 <= 0
 C3. c1 * gen_2
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C4. Is_a([], List.tl s2)
 C5. c1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.3.2''''.7.2:

 H0. c1 * gen_2 +. eval_poly [] x <= 0
 H1. Is_a(Geq, List.hd s2)
 H2. well_formed (List.tl s2) x
 H3. s2 <> []
 H4. eval_system (List.tl s2) x
 H5. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H6. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H7. c2 <> []
 H8. Is_a([], List.tl s2)
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. List.hd c2 >= 0
 C3. gen_2 <= 0
 C4. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq and well_formed.

Subgoal 1.3.2''''.7.1:

 H0. Is_a(Geq, List.hd s2)
 H1. s2 <> []
 H2. eval_system (List.tl s2) x
 H3. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H4. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H5. c2 <> []
 H6. Is_a([], List.tl s2)
 H7. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. List.hd c2 >= 0
 C3. gen_2 <= 0
 C4. well_formed (List.tl s2) x
 C5. c1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
p_add, scale_system and sum_polys.

Subgoal 1.3.2''''.6:

 H0. well_formed s2 x
 H1. eval_system s2 x
 H2. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H3. good_poly_length s11 x
 H4. s2 <> []
 H5. c2 <> []
 H6. not Is_a(Eq, List.hd s2)
 H7. not Is_a(Geq, List.hd s2)
 H8. List.hd c2 <= 0
 H9. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

Subgoal 1.3.2''''.5:

 H0. s2 <> []
 H1. c2 <> []
 H2. Is_a(Eq, List.hd s2)
 H3. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H4. well_formed s2 x
 H5. eval_system s2 x
 H6. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.3.2''''.5.3:

 H0. c1 * gen_2
     +. eval_poly
        (p_add (p_scale (Destruct(Eq, 0, List.hd s2)) (List.hd c2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. Is_a(Eq, List.hd s2)
 H5. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H6. c2 <> []
 H7. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. gen_2 <= 0
 C2. c1 * gen_2
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C3. Is_a([], List.tl s2)
 C4. c1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.3.2''''.5.2:

 H0. c1 * gen_2 +. eval_poly [] x <= 0
 H1. well_formed (List.tl s2) x
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. Is_a(Eq, List.hd s2)
 H5. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H6. c2 <> []
 H7. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H8. Is_a([], List.tl s2)
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. gen_2 <= 0
 C3. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq and well_formed.

Subgoal 1.3.2''''.5.1:

 H0. c1 * gen_2
     +. eval_poly
        (p_add (p_scale (Destruct(Eq, 0, List.hd s2)) (List.hd c2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H1. s2 <> []
 H2. eval_system (List.tl s2) x
 H3. Is_a(Eq, List.hd s2)
 H4. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H5. c2 <> []
 H6. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H7. Is_a([], List.tl s2)
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. gen_2 <= 0
 C3. well_formed (List.tl s2) x
 C4. c1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

Subgoal 1.3.2''''.4:

 H0. s2 <> []
 H1. c2 <> []
 H2. not Is_a(Eq, List.hd s2)
 H3. Is_a(Geq, List.hd s2)
 H4. List.hd c2 >= 0
 H5. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H6. well_formed s2 x
 H7. eval_system s2 x
 H8. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.3.2''''.4.3:

 H0. Is_a(Geq, List.hd s2)
 H1. well_formed (List.tl s2) x
 H2. List.hd c2 >= 0
 H3. s2 <> []
 H4. eval_system (List.tl s2) x
 H5. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H6. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H7. c1 * gen_2
     +. eval_poly
        (p_add (p_scale (Destruct(Geq, 0, List.hd s2)) (List.hd c2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H8. c2 <> []
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. gen_2 <= 0
 C2. c1 * gen_2
     +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x <= 0
 C3. Is_a([], List.tl s2)
 C4. c1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull, eval_poly_scale, good_length_p_scale and
sum_poly_good_length.

Subgoal 1.3.2''''.4.2:

 H0. c1 * gen_2 +. eval_poly [] x <= 0
 H1. Is_a(Geq, List.hd s2)
 H2. well_formed (List.tl s2) x
 H3. List.hd c2 >= 0
 H4. s2 <> []
 H5. eval_system (List.tl s2) x
 H6. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H7. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H8. c2 <> []
 H9. Is_a([], List.tl s2)
 H10. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. gen_2 <= 0
 C3. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq and well_formed.

Subgoal 1.3.2''''.4.1:

 H0. Is_a(Geq, List.hd s2)
 H1. List.hd c2 >= 0
 H2. s2 <> []
 H3. eval_system (List.tl s2) x
 H4. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H5. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
 H6. c1 * gen_2
     +. eval_poly
        (p_add (p_scale (Destruct(Geq, 0, List.hd s2)) (List.hd c2))
         (sum_polys (scale_system (List.tl s2) (List.tl c2))))
        x
     <= 0
 H7. c2 <> []
 H8. Is_a([], List.tl s2)
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) (List.tl c2))
 C1. has_strict_ineq (List.tl s2)
 C2. gen_2 <= 0
 C3. well_formed (List.tl s2) x
 C4. c1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
p_add, scale_system and sum_polys.

Subgoal 1.3.2''''.3:

 H0. s2 <> []
 H1. c2 <> []
 H2. not Is_a(Eq, List.hd s2)
 H3. not Is_a(Geq, List.hd s2)
 H4. not (List.hd c2 <= 0)
 H5. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c2))) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H6. well_formed s2 x
 H7. eval_system s2 x
 H8. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H9. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq, p_add, scale_system, sum_polys and well_formed.

Subgoal 1.3.2''''.2:

 H0. s2 <> []
 H1. not (c2 <> [])
 H2. Is_a(Eq, List.hd s2)
 H3. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H4. well_formed s2 x
 H5. eval_system s2 x
 H6. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, scale_system, sum_polys and well_formed to the following 2
subgoals:

Subgoal 1.3.2''''.2.2:

 H0. well_formed (List.tl s2) x
 H1. s2 <> []
 H2. eval_system (List.tl s2) x
 H3. Is_a(Eq, List.hd s2)
 H4. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Eq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H5. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H6. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. c2 <> []
 C2. c1 * gen_2 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x
     <= 0
 C3. gen_2 <= 0
 C4. Is_a([], scale_system (List.tl s2) c2)
 C5. Is_a([], List.tl s2)
 C6. c1 <= 0

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.3.2''''.2.1:

 H0. s2 <> []
 H1. eval_system (List.tl s2) x
 H2. Is_a(Eq, List.hd s2)
 H3. c1 * gen_2
     +. eval_poly
        (p_add (Destruct(Eq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c2)))
        x
     <= 0
 H4. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H5. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H6. Is_a([], List.tl s2)
 H7. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. has_strict_ineq (List.tl s2)
 C1. c2 <> []
 C2. gen_2 <= 0
 C3. Is_a([], scale_system (List.tl s2) c2)
 C4. c1 <= 0

But simplification reduces this to true, using the definitions of eval_poly,
p_add, scale_system and sum_polys.

Subgoal 1.3.2''''.1:

 H0. s2 <> []
 H1. not (c2 <> [])
 H2. not Is_a(Eq, List.hd s2)
 H3. not Is_a(Geq, List.hd s2)
 H4. not (well_formed (List.tl s2) x) || has_strict_ineq (List.tl s2)
     || (gen_2 <= 0) || not (eval_system (List.tl s2) x)
     || Is_a([], List.tl s2)
     || not
        (c1 * gen_2 +. eval_poly (sum_polys (scale_system (List.tl s2) c2)) x
         <= 0)
     || (c1 <= 0) || not (good_poly_length s11 x)
 H5. well_formed s2 x
 H6. eval_system s2 x
 H7. c1 * gen_2 +. eval_poly (sum_polys (scale_system s2 c2)) x <= 0
 H8. good_poly_length s11 x
|---------------------------------------------------------------------------
 C0. gen_2 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c1 <= 0

But simplification reduces this to true, using the definitions of
eval_system, has_strict_ineq, scale_system, sum_polys and well_formed.

Subgoal 1.3.1:

 H0. c <> []
 H1. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H2. eval_poly [] x <= 0
 H3. Is_a([], List.tl s)
 H4. s <> []
 H5. eval_system (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. List.hd c <= 0
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. Is_a([], scale_system (List.tl s) (List.tl c))

But simplification reduces this to true, using the definition of
scale_system.

Subgoal 1.2:

 H0. s <> []
 H1. not (c <> [])
 H2. Is_a(Eq, List.hd s)
 H3. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || not (eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0)
     || (List.tl s = []) || not (well_formed (List.tl s) x)
 H4. eval_poly (sum_polys (scale_system s c)) x <= 0
 H5. s <> []
 H6. has_strict_ineq s
 H7. well_formed s x
 H8. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.2.3:

 H0. Is_a(Eq, List.hd s)
 H1. s <> []
 H2. eval_system (List.tl s) x
 H3. has_strict_ineq (List.tl s)
 H4. well_formed (List.tl s) x
 H5. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H6. good_poly_length (Destruct(Eq, 0, List.hd s)) x
 H7. eval_poly
     (p_add (Destruct(Eq, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x <= 0
|---------------------------------------------------------------------------
 C0. c <> []
 C1. eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0
 C2. Is_a([], List.tl s)

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.2.2:

 H0. Is_a(Eq, List.hd s)
 H1. eval_poly [] x <= 0
 H2. Is_a([], List.tl s)
 H3. s <> []
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H7. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 C0. c <> []
 C1. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.2.1:

 H0. Is_a(Eq, List.hd s)
 H1. Is_a([], List.tl s)
 H2. Is_a([], scale_system (List.tl s) c)
 H3. s <> []
 H4. eval_system (List.tl s) x
 H5. has_strict_ineq (List.tl s)
 H6. eval_poly (Destruct(Eq, 0, List.hd s)) x <= 0
 H7. eval_poly (Destruct(Eq, 0, List.hd s)) x = 0
 H8. good_poly_length (Destruct(Eq, 0, List.hd s)) x
|---------------------------------------------------------------------------
 c <> []

But simplification reduces this to true, using the definition of
has_strict_ineq.

Subgoal 1.1:

 H0. s <> []
 H1. not (c <> [])
 H2. not Is_a(Eq, List.hd s)
 H3. not Is_a(Geq, List.hd s)
 H4. not (eval_system (List.tl s) x) || not (has_strict_ineq (List.tl s))
     || not (eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0)
     || (List.tl s = []) || not (well_formed (List.tl s) x)
 H5. eval_poly (sum_polys (scale_system s c)) x <= 0
 H6. s <> []
 H7. has_strict_ineq s
 H8. well_formed s x
 H9. eval_system s x
|---------------------------------------------------------------------------
 false

This simplifies, using the definitions of eval_poly, eval_system,
has_strict_ineq, p_add, scale_system, sum_polys and well_formed to the
following 3 subgoals:

Subgoal 1.1.3:

 H0. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H1. s <> []
 H2. eval_system (List.tl s) x
 H3. has_strict_ineq (List.tl s)
 H4. well_formed (List.tl s) x
 H5. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x <= 0
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. c <> []
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0
 C5. Is_a([], List.tl s)

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.1.2:

 H0. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H1. s <> []
 H2. eval_system (List.tl s) x
 H3. well_formed (List.tl s) x
 H4. eval_poly
     (p_add (Destruct(Gt, 0, List.hd s))
      (sum_polys (scale_system (List.tl s) c)))
     x <= 0
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. c <> []
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. has_strict_ineq (List.tl s)
 C5. Is_a([], List.tl s)

This simplifies, using the rewrite rules eval_p_add_pull and
sum_poly_good_length to:

Subgoal 1.1.2':

 H0. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H1. s <> []
 H2. eval_system (List.tl s) x
 H3. well_formed (List.tl s) x
 H4. eval_poly (Destruct(Gt, 0, List.hd s)) x
     +. eval_poly (sum_polys (scale_system (List.tl s) c)) x <= 0
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. c <> []
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. has_strict_ineq (List.tl s)
 C5. Is_a([], List.tl s)


We can eliminate destructors by the following substitution:
 s -> s1 :: s2

This produces the modified subgoal:

Subgoal 1.1.2'':

 H0. well_formed s2 x
 H1. good_poly_length (Destruct(Gt, 0, s1)) x
 H2. eval_poly (Destruct(Gt, 0, s1)) x
     +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. c <> []
 C2. Is_a(Geq, s1)
 C3. Is_a(Eq, s1)
 C4. has_strict_ineq s2
 C5. eval_poly (Destruct(Gt, 0, s1)) x <= 0


We can eliminate destructors by the following substitution:
 s1 -> Gt s11

This produces the modified subgoal:

Subgoal 1.1.2''':

 H0. eval_poly s11 x +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H1. well_formed s2 x
 H2. good_poly_length s11 x
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. c <> []
 C2. eval_poly s11 x <= 0
 C3. has_strict_ineq s2


Candidates for generalization:

 eval_poly s11 x

This produces the modified subgoal:

Subgoal 1.1.2'''':

 H0. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H1. well_formed s2 x
 H2. good_poly_length s11 x
 H3. eval_system s2 x
|---------------------------------------------------------------------------
 C0. Is_a([], s2)
 C1. c <> []
 C2. gen_3 <= 0
 C3. has_strict_ineq s2


Must try induction.

The recursive terms in the conjecture suggest 5 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from scale_system.

Induction scheme:

 (not
  (not Is_a(Geq, List.hd s2)
   && (not Is_a(Eq, List.hd s2) && (not (c <> []) && s2 <> [])))
  && (not (Is_a(Eq, List.hd s2) && (not (c <> []) && s2 <> []))
      && (not
          ((List.hd c >. 0)
           && (not Is_a(Geq, List.hd s2)
               && (not Is_a(Eq, List.hd s2) && (c <> [] && s2 <> []))))
          && (not
              ((List.hd c >=. 0)
               && (Is_a(Geq, List.hd s2)
                   && (not Is_a(Eq, List.hd s2) && (c <> [] && s2 <> []))))
              && (not (Is_a(Eq, List.hd s2) && (c <> [] && s2 <> []))
                  && (not
                      (not (List.hd c >. 0)
                       && (not Is_a(Geq, List.hd s2)
                           && (not Is_a(Eq, List.hd s2)
                               && (c <> [] && s2 <> []))))
                      && (not
                          (not (List.hd c >=. 0)
                           && (Is_a(Geq, List.hd s2)
                               && (not Is_a(Eq, List.hd s2)
                                   && (c <> [] && s2 <> []))))
                          && not
                             (Is_a(Geq, List.hd s2)
                              && (not Is_a(Eq, List.hd s2)
                                  && (not (c <> []) && s2 <> [])))))))))
  ==> φ c gen_3 s11 s2 x)
 && ((s2 <> []
      && (not (c <> [])
          && (not Is_a(Eq, List.hd s2)
              && (Is_a(Geq, List.hd s2) && φ c gen_3 s11 (List.tl s2) x)))
      ==> φ c gen_3 s11 s2 x)
     && ((s2 <> []
          && (c <> []
              && (not Is_a(Eq, List.hd s2)
                  && (Is_a(Geq, List.hd s2)
                      && (not (List.hd c >=. 0)
                          && φ (List.tl c) gen_3 s11 (List.tl s2) x))))
          ==> φ c gen_3 s11 s2 x)
         && ((s2 <> []
              && (c <> []
                  && (not Is_a(Eq, List.hd s2)
                      && (not Is_a(Geq, List.hd s2)
                          && (not (List.hd c >. 0)
                              && φ (List.tl c) gen_3 s11 (List.tl s2) x))))
              ==> φ c gen_3 s11 s2 x)
             && ((s2 <> []
                  && (c <> []
                      && (Is_a(Eq, List.hd s2)
                          && φ (List.tl c) gen_3 s11 (List.tl s2) x))
                  ==> φ c gen_3 s11 s2 x)
                 && ((s2 <> []
                      && (c <> []
                          && (not Is_a(Eq, List.hd s2)
                              && (Is_a(Geq, List.hd s2)
                                  && ((List.hd c >=. 0)
                                      && φ (List.tl c) gen_3 s11
                                         (List.tl s2) x))))
                      ==> φ c gen_3 s11 s2 x)
                     && ((s2 <> []
                          && (c <> []
                              && (not Is_a(Eq, List.hd s2)
                                  && (not Is_a(Geq, List.hd s2)
                                      && ((List.hd c >. 0)
                                          && φ (List.tl c) gen_3 s11
                                             (List.tl s2) x))))
                          ==> φ c gen_3 s11 s2 x)
                         && ((s2 <> []
                              && (not (c <> [])
                                  && (Is_a(Eq, List.hd s2)
                                      && φ c gen_3 s11 (List.tl s2) x))
                              ==> φ c gen_3 s11 s2 x)
                             && (s2 <> []
                                 && (not (c <> [])
                                     && (not Is_a(Eq, List.hd s2)
                                         && (not Is_a(Geq, List.hd s2)
                                             && φ c gen_3 s11 (List.tl s2) x)))
                                 ==> φ c gen_3 s11 s2 x)))))))).

9 nontautological subgoals.

Subgoal 1.1.2''''.9:

 H0. eval_system s2 x
 H1. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H2. good_poly_length s11 x
 H3. well_formed s2 x
 H4. not
     (not Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c <> [])
      && s2 <> [])
 H5. not (Is_a(Eq, List.hd s2) && not (c <> []) && s2 <> [])
 H6. not
     (not (List.hd c <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c <> [] && s2 <> [])
 H7. not
     ((List.hd c >= 0) && Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2)
      && c <> [] && s2 <> [])
 H8. not (Is_a(Eq, List.hd s2) && c <> [] && s2 <> [])
 H9. not
     ((List.hd c <= 0) && not Is_a(Geq, List.hd s2)
      && not Is_a(Eq, List.hd s2) && c <> [] && s2 <> [])
 H10. not
      (not (List.hd c >= 0) && Is_a(Geq, List.hd s2)
       && not Is_a(Eq, List.hd s2) && c <> [] && s2 <> [])
 H11. not
      (Is_a(Geq, List.hd s2) && not Is_a(Eq, List.hd s2) && not (c <> [])
       && s2 <> [])
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But simplification reduces this to true, using the forward-chaining rules
add_negative and scale_system_not_empty.

Subgoal 1.1.2''''.8:

 H0. eval_system s2 x
 H1. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H2. good_poly_length s11 x
 H3. s2 <> []
 H4. not (c <> [])
 H5. not Is_a(Eq, List.hd s2)
 H6. Is_a(Geq, List.hd s2)
 H7. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x) || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
     || not
        (gen_3 +. eval_poly (sum_polys (scale_system (List.tl s2) c)) x <= 0)
     || c <> []
 H8. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.1.2''''.8.3:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. Is_a(Geq, List.hd s2)
 H3. well_formed (List.tl s2) x
 H4. good_poly_length s11 x
 H5. gen_3
     +. eval_poly
        (p_add (Destruct(Geq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c)))
        x
     <= 0
 H6. eval_system (List.tl s2) x
 H7. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
|---------------------------------------------------------------------------
 C0. gen_3 +. eval_poly (sum_polys (scale_system (List.tl s2) c)) x <= 0
 C1. gen_3 <= 0
 C2. Is_a([], List.tl s2)
 C3. has_strict_ineq (List.tl s2)
 C4. c <> []

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.1.2''''.8.2:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. Is_a(Geq, List.hd s2)
 H3. well_formed (List.tl s2) x
 H4. good_poly_length s11 x
 H5. eval_system (List.tl s2) x
 H6. gen_3 +. eval_poly [] x <= 0
 H7. Is_a([], List.tl s2)
 H8. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c)
 C1. gen_3 <= 0
 C2. has_strict_ineq (List.tl s2)
 C3. c <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.1.2''''.8.1:

 H0. good_poly_length (Destruct(Geq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. Is_a(Geq, List.hd s2)
 H3. good_poly_length s11 x
 H4. eval_system (List.tl s2) x
 H5. gen_3 +. eval_poly [] x <= 0
 H6. Is_a([], List.tl s2)
 H7. eval_poly (Destruct(Geq, 0, List.hd s2)) x >= 0
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c)
 C1. well_formed (List.tl s2) x
 C2. gen_3 <= 0
 C3. has_strict_ineq (List.tl s2)
 C4. c <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.1.2''''.7:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. c <> []
 H3. not Is_a(Eq, List.hd s2)
 H4. Is_a(Geq, List.hd s2)
 H5. not (List.hd c >= 0)
 H6. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x)
     || not
        (gen_3
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c))) x
         <= 0)
     || (List.tl c) <> [] || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
 H7. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But this is immediate by our hypotheses.

Subgoal 1.1.2''''.6:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. c <> []
 H3. not Is_a(Eq, List.hd s2)
 H4. not Is_a(Geq, List.hd s2)
 H5. List.hd c <= 0
 H6. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x)
     || not
        (gen_3
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c))) x
         <= 0)
     || (List.tl c) <> [] || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
 H7. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But this is immediate by our hypotheses.

Subgoal 1.1.2''''.5:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. c <> []
 H3. Is_a(Eq, List.hd s2)
 H4. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x)
     || not
        (gen_3
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c))) x
         <= 0)
     || (List.tl c) <> [] || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
 H5. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H6. good_poly_length s11 x
 H7. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But this is immediate by our hypotheses.

Subgoal 1.1.2''''.4:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. c <> []
 H3. not Is_a(Eq, List.hd s2)
 H4. Is_a(Geq, List.hd s2)
 H5. List.hd c >= 0
 H6. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x)
     || not
        (gen_3
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c))) x
         <= 0)
     || (List.tl c) <> [] || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
 H7. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But this is immediate by our hypotheses.

Subgoal 1.1.2''''.3:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. c <> []
 H3. not Is_a(Eq, List.hd s2)
 H4. not Is_a(Geq, List.hd s2)
 H5. not (List.hd c <= 0)
 H6. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x)
     || not
        (gen_3
         +. eval_poly (sum_polys (scale_system (List.tl s2) (List.tl c))) x
         <= 0)
     || (List.tl c) <> [] || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
 H7. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H8. good_poly_length s11 x
 H9. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But this is immediate by our hypotheses.

Subgoal 1.1.2''''.2:

 H0. eval_system s2 x
 H1. s2 <> []
 H2. not (c <> [])
 H3. Is_a(Eq, List.hd s2)
 H4. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x) || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
     || not
        (gen_3 +. eval_poly (sum_polys (scale_system (List.tl s2) c)) x <= 0)
     || c <> []
 H5. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H6. good_poly_length s11 x
 H7. well_formed s2 x
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

This simplifies, using the definitions of eval_system, has_strict_ineq,
p_add, scale_system, sum_polys and well_formed to the following 3 subgoals:

Subgoal 1.1.2''''.2.3:

 H0. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. well_formed (List.tl s2) x
 H3. gen_3
     +. eval_poly
        (p_add (Destruct(Eq, 0, List.hd s2))
         (sum_polys (scale_system (List.tl s2) c)))
        x
     <= 0
 H4. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H5. good_poly_length s11 x
 H6. Is_a(Eq, List.hd s2)
 H7. eval_system (List.tl s2) x
|---------------------------------------------------------------------------
 C0. gen_3 +. eval_poly (sum_polys (scale_system (List.tl s2) c)) x <= 0
 C1. gen_3 <= 0
 C2. Is_a([], List.tl s2)
 C3. has_strict_ineq (List.tl s2)
 C4. c <> []

But simplification reduces this to true, using the rewrite rules
eval_p_add_pull and sum_poly_good_length.

Subgoal 1.1.2''''.2.2:

 H0. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. well_formed (List.tl s2) x
 H3. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H4. good_poly_length s11 x
 H5. Is_a(Eq, List.hd s2)
 H6. eval_system (List.tl s2) x
 H7. gen_3 +. eval_poly [] x <= 0
 H8. Is_a([], List.tl s2)
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c)
 C1. gen_3 <= 0
 C2. has_strict_ineq (List.tl s2)
 C3. c <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.1.2''''.2.1:

 H0. good_poly_length (Destruct(Eq, 0, List.hd s2)) x
 H1. s2 <> []
 H2. eval_poly (Destruct(Eq, 0, List.hd s2)) x = 0
 H3. good_poly_length s11 x
 H4. Is_a(Eq, List.hd s2)
 H5. eval_system (List.tl s2) x
 H6. gen_3 +. eval_poly [] x <= 0
 H7. Is_a([], List.tl s2)
|---------------------------------------------------------------------------
 C0. Is_a([], scale_system (List.tl s2) c)
 C1. well_formed (List.tl s2) x
 C2. gen_3 <= 0
 C3. has_strict_ineq (List.tl s2)
 C4. c <> []

But simplification reduces this to true, using the definition of eval_poly.

Subgoal 1.1.2''''.1:

 H0. eval_system s2 x
 H1. gen_3 +. eval_poly (sum_polys (scale_system s2 c)) x <= 0
 H2. good_poly_length s11 x
 H3. well_formed s2 x
 H4. s2 <> []
 H5. not (c <> [])
 H6. not Is_a(Eq, List.hd s2)
 H7. not Is_a(Geq, List.hd s2)
 H8. (gen_3 <= 0) || not (well_formed (List.tl s2) x)
     || not (good_poly_length s11 x) || Is_a([], List.tl s2)
     || has_strict_ineq (List.tl s2) || not (eval_system (List.tl s2) x)
     || not
        (gen_3 +. eval_poly (sum_polys (scale_system (List.tl s2) c)) x <= 0)
     || c <> []
|---------------------------------------------------------------------------
 C0. gen_3 <= 0
 C1. Is_a([], s2)
 C2. has_strict_ineq s2
 C3. c <> []

But simplification reduces this to true, using the definitions of
has_strict_ineq and well_formed.

Subgoal 1.1.1:

 H0. good_poly_length (Destruct(Gt, 0, List.hd s)) x
 H1. eval_poly [] x <= 0
 H2. Is_a([], List.tl s)
 H3. s <> []
 H4. eval_system (List.tl s) x
|---------------------------------------------------------------------------
 C0. Is_a(Geq, List.hd s)
 C1. Is_a(Eq, List.hd s)
 C2. c <> []
 C3. eval_poly (Destruct(Gt, 0, List.hd s)) x <= 0
 C4. Is_a([], scale_system (List.tl s) c)

But simplification reduces this to true, using the definitions of eval_system
and scale_system.

 ⓘ  Rules:
    (:def eval_poly)
    (:def eval_system)
    (:def has_strict_ineq)
    (:def p_add)
    (:def scale_system)
    (:def sum_polys)
    (:def well_formed)
    (:rw eval_p_add_pull)
    (:rw eval_poly_scale)
    (:rw good_length_p_scale)
    (:rw sum_poly_good_length)
    (:fc add_negative)
    (:fc eval_p_add_pull)
    (:fc eval_poly_scale)
    (:fc scale_system_not_empty)
    (:induct scale_system)

[✓] Theorem proved.
val positive_solution_certificate' : system -> real list -> var_vect -> bool =
  <fun>
Goal:

well_formed s x && (has_strict_ineq s && eval_system s x)
==> not (eval_poly (mk_certificate s c) x <=. 0).

A hint has been given, resulting in the following augmented conjecture:

Goal':

(well_formed s x && (eval_system s x && (not (s = []) && has_strict_ineq s))
 ==> eval_poly (sum_polys (scale_system s c)) x > 0)
==> well_formed s x && (has_strict_ineq s && eval_system s x)
    ==> not (eval_poly (sum_polys (scale_system s c)) x <= 0).

1 nontautological subgoal.

Subgoal 1:

 H0. eval_poly (sum_polys (scale_system s c)) x <= 0
 H1. well_formed s x
 H2. has_strict_ineq s
 H3. eval_system s x
 H4. not
     (well_formed s x && eval_system s x && not (s = []) && has_strict_ineq s)
     || not (eval_poly (sum_polys (scale_system s c)) x <= 0)
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definitions of eval_system
and has_strict_ineq.

 ⓘ  Rules:
    (:def eval_system)
    (:def has_strict_ineq)
    (:fc scale_system_not_empty)
    (:app apply_hint.positive_solution_certificate'.0)

[✓] Theorem proved.
val farkas_lemma_strict_ineq : system -> var_vect -> certificate -> bool =
  <fun>
Goal:

well_formed s x && (has_strict_ineq s && check_cert s c)
==> eval_system s x = false.

A hint has been given, resulting in the following augmented conjecture:

Goal':

(well_formed s x
 && (has_strict_ineq s
     && (if has_strict_ineq s
         then is_nonpos_constant (sum_polys (scale_system s c))
         else is_neg_constant (sum_polys (scale_system s c))))
 ==> eval_poly (sum_polys (scale_system s c)) x <= 0)
&& (well_formed s x && (has_strict_ineq s && eval_system s x)
    ==> not (eval_poly (sum_polys (scale_system s c)) x <= 0))
==> well_formed s x
    && (has_strict_ineq s
        && (if has_strict_ineq s
            then is_nonpos_constant (sum_polys (scale_system s c))
            else is_neg_constant (sum_polys (scale_system s c))))
    ==> eval_system s x = false.

1 nontautological subgoal.

Subgoal 1:

 H0. well_formed s x
 H1. has_strict_ineq s
 H2. if has_strict_ineq s
     then is_nonpos_constant (sum_polys (scale_system s c))
     else is_neg_constant (sum_polys (scale_system s c))
 H3. eval_system s x
 H4. well_formed s x && has_strict_ineq s
     && (if has_strict_ineq s
         then is_nonpos_constant (sum_polys (scale_system s c))
         else is_neg_constant (sum_polys (scale_system s c)))
     ==> eval_poly (sum_polys (scale_system s c)) x <= 0
 H5. not (well_formed s x && has_strict_ineq s && eval_system s x)
     || not (eval_poly (sum_polys (scale_system s c)) x <= 0)
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the forward-chaining rule
scale_system_not_empty.

 ⓘ  Rules:
    (:fc scale_system_not_empty)
    (:app apply_hint.farkas_lemma_strict_ineq.0)
    (:app apply_hint.farkas_lemma_strict_ineq.1)

[✓] Theorem proved.
